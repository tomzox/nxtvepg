/*
 *  XMLTV element parser
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License Version 2 as
 *  published by the Free Software Foundation. You find a copy of this
 *  license in the file COPYRIGHT in the root directory of this release.
 *
 *  THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 *  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *
 *  Description:
 *
 *    This module processes XML tags and attributes and the respective
 *    data.  It's based on a scanner generated by "flex" which breaks
 *    down the input file into tokens and invokes callback functions
 *    in this module to process these tokens.
 *
 *    TODO:
 *    - re-sync after error when toplevel tags are found: channel, timeslot (programme)
 *    - search stack upwards when mis-matching closing tag is encountered
 *    - don't accept PCDATA or attributes in error state
 *    - don't accept tags or PCDATA after </tv>
 *    - check that attribute is set only once per tag (XML spec ch. 3.1)
 *    - complain about unexpected PCDATA in non-MIXED elements
 *    - strip whitespace from attributes which are not of type CDATA
 *    - transcode non-ASCII chars in tag and attribute names (not req. for XMLTV)
 *    - dynamically grow parser stack if necessary (not req. for w.-f. XMLTV)
 *
 *  Author: Tom Zoerner
 *
 *  $Id: xmltv_tags.c,v 1.13 2020/06/17 08:27:36 tom Exp tom $
 */

#define DEBUG_SWITCH DEBUG_SWITCH_XMLTV
#define DPRINTF_OFF

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "epgctl/mytypes.h"
#include "epgctl/debug.h"

#include "xmltv/xml_cdata.h"
#include "xmltv/xmltv_db.h"
#include "xmltv/xmltv_tags.h"

extern FILE *yyin;
extern int yyparse( void );
extern int yylex( void );

// ----------------------------------------------------------------------------
// Definition of tags and their hierarchy
//
typedef enum
{
   // tags according DTD 0.5
   XMLTV5_TOP,
   XMLTV5_TV,
   XMLTV5_CHANNEL,
      XMLTV5_CHN_DISP_NAME,
      XMLTV5_CHN_ICON,
      XMLTV5_CHN_URL,
   XMLTV5_PROG,
      XMLTV5_PI_TITLE,
      XMLTV5_PI_TITLE2,
      XMLTV5_PI_DESC,
      XMLTV5_PI_CREDITS,
         XMLTV5_PI_CRED_DIR,
         XMLTV5_PI_CRED_ACT,
         XMLTV5_PI_CRED_WRI,
         XMLTV5_PI_CRED_ADAP,
         XMLTV5_PI_CRED_PROD,
         XMLTV5_PI_CRED_PRES,
         XMLTV5_PI_CRED_COMM,
         XMLTV5_PI_CRED_GUEST,
      XMLTV5_PI_DATE,
      XMLTV5_PI_CAT,
      XMLTV5_PI_VIDEO,
         XMLTV5_PI_VIDEO_ASPECT,
         XMLTV5_PI_VIDEO_COLOUR,
         XMLTV5_PI_VIDEO_QUALITY,
      XMLTV5_PI_AUDIO,
         XMLTV5_PI_AUDIO_STEREO,
      XMLTV5_PI_SUBT,
      XMLTV5_PI_PRAT,
         XMLTV5_PI_PRAT_VAL,
      XMLTV5_PI_ERAT,
         XMLTV5_PI_ERAT_VAL,
   // format detection & catch-all for unrecognized tags
   XMLTV_DETECT,
      XMLTV_DETECT_TV,
      XMLTV_DETECT_PROG,
   XMLTV_SKIP,
   XMLTV_TAG_COUNT
} XMLTV_TAG;

// ----------------------------------------------------------------------------
// Tag hierarchy for XMLTV DTD 0.5
// - note: tags are sorted by probability to speed-up name comparison

static const XMLTV_TAG xmltv5_tags_top[] =
{
   XMLTV5_TV
};
static const XMLTV_TAG xmltv5_tags_tv[] =
{
   XMLTV5_PROG,
   XMLTV5_CHANNEL
};
static const XMLTV_TAG xmltv5_tags_channel[] =
{
   XMLTV5_CHN_DISP_NAME,
   XMLTV5_CHN_ICON,
   XMLTV5_CHN_URL
};
static const XMLTV_TAG xmltv5_tags_programme[] =
{
   XMLTV5_PI_TITLE,
   XMLTV5_PI_DESC,
   XMLTV5_PI_CAT,
   XMLTV5_PI_VIDEO,
   XMLTV5_PI_AUDIO,
   XMLTV5_PI_PRAT,
   XMLTV5_PI_ERAT,
   XMLTV5_PI_SUBT,
   XMLTV5_PI_DATE,
   XMLTV5_PI_CREDITS,
   XMLTV5_PI_TITLE2
};
static const XMLTV_TAG xmltv5_tags_credits[] =
{
   XMLTV5_PI_CRED_DIR,
   XMLTV5_PI_CRED_ACT,
   XMLTV5_PI_CRED_WRI,
   XMLTV5_PI_CRED_ADAP,
   XMLTV5_PI_CRED_PROD,
   XMLTV5_PI_CRED_PRES,
   XMLTV5_PI_CRED_COMM,
   XMLTV5_PI_CRED_GUEST
};
static const XMLTV_TAG xmltv5_tags_video[] =
{
   XMLTV5_PI_VIDEO_ASPECT,
   XMLTV5_PI_VIDEO_COLOUR,
   XMLTV5_PI_VIDEO_QUALITY
};
static const XMLTV_TAG xmltv5_tags_audio[] =
{
   XMLTV5_PI_AUDIO_STEREO
};
static const XMLTV_TAG xmltv5_tags_prat[] =
{
   XMLTV5_PI_PRAT_VAL
};
static const XMLTV_TAG xmltv5_tags_erat[] =
{
   XMLTV5_PI_ERAT_VAL
};

// ----------------------------------------------------------------------------
// Tag hierarchy for format detection

static const XMLTV_TAG xmltv_auto_detect[] =
{
   XMLTV_DETECT_TV
};
static const XMLTV_TAG xmltv_auto_detect_tv[] =
{
   XMLTV_DETECT_PROG,
};

static void XmltvTags_SetLanguage( XML_STR_BUF * pBuf );
static void XmltvTags_SetVersion5_ByTag( void );
static void XmltvTags_SetVersion5_ByAttr( XML_STR_BUF * pBuf );

// ----------------------------------------------------------------------------
// Definition of DTD 0.5 tag attributes & their callback functions
//

typedef struct
{
   const char * pName;
   void (* SetAttr) ( XML_STR_BUF * pBuf );
   bool strip;
} XMLTV_ATTS;

#define XMLTV_ATT_STRIP TRUE

static const XMLTV_ATTS xmltv5_attr_tv[] =
{
   { "source-info-name", Xmltv_AboutSetSourceInfoName, FALSE },
   { "source-info-url", Xmltv_AboutSetSourceInfoUrl, FALSE },
   { "source-data-url", Xmltv_AboutSetSourceDataUrl, FALSE },
   { "generator-info-name", Xmltv_AboutSetGenInfoName, FALSE },
   { "generator-info-url", Xmltv_AboutSetGenInfoUrl, FALSE },
   { "date", NULL, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_channel[] =
{
   { "id", Xmltv_ChannelSetId, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_disp_name[] =
{
   { "lang", XmltvTags_SetLanguage, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_icon[] =
{
   { "src", NULL, FALSE },
   { "width", NULL, FALSE },
   { "height", NULL, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_prog[] =
{
   { "start", Xmltv_TsSetStartTime, FALSE },
   { "stop", Xmltv_TsSetStopTime, FALSE },
   { "channel", Xmltv_TsSetChannel, FALSE },
   { "pdc-start", Xmltv_TsCodeTimeSetPdc, FALSE },
   { "vps-start", Xmltv_TsCodeTimeSetVps, FALSE },
   { "showview", Xmltv_TsCodeTimeSetSV, FALSE },
   { "videoplus", Xmltv_TsCodeTimeSetVP, FALSE },
   { "clumpidx", NULL, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_pi_subt[] =
{
   { "type", Xmltv_PiSubtitlesSetType, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_pi_prat[] =
{
   { "system", Xmltv_PiRatingSetSystem, FALSE }
};
static const XMLTV_ATTS xmltv5_attr_lang_only[] =
{
   { "lang", XmltvTags_SetLanguage, FALSE }
};

// ----------------------------------------------------------------------------

typedef enum
{
   XML_NO_PCDATA = 0,
   XML_HAS_PCDATA,
   XML_DISCARD_PCDATA,
   XML_PCDATA_UNSTRIPPED
} XML_PCDATA_DEF;

typedef struct
{
   XMLTV_TAG            tagIdx;
   const char         * pTagName;
   const XMLTV_TAG    * pChilds;
   uint                 childCount;
   XML_PCDATA_DEF       hasPcData;
   struct {
      void (* TagOpen) ( void );
      void (* TagClose) ( void );
      void (* AddContent) ( XML_STR_BUF * pBuf );
      bool (* PostAttr) ( void );
   } cb;
   struct {
      const XMLTV_ATTS * pTagAttr;
      uint              attrCount;
   } at;
} XML_TAGDEF;

#define XML_CHILDS(L)           (L), sizeof(L)/sizeof((L)[0])
#define XML_NO_CHILDS           NULL, 0
#define XMLTV_NO_OPEN_CLOSE_CB  { NULL, NULL, NULL, NULL }
#define XMLTV_ATTR(L)           { (L), sizeof(L)/sizeof((L)[0]) }
#define XMLTV_NO_ATTR           { NULL, 0 }

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Definition of tag attributes for DTD version auto-detection

static const XMLTV_ATTS xmltv_auto_detect_attr_tv[] =
{
   { "source-info-name", XmltvTags_SetVersion5_ByAttr, FALSE },
   { "source-info-url", XmltvTags_SetVersion5_ByAttr, FALSE },
   { "source-data-url", XmltvTags_SetVersion5_ByAttr, FALSE },
   { "generator-info-name", XmltvTags_SetVersion5_ByAttr, FALSE },
   { "generator-info-url", XmltvTags_SetVersion5_ByAttr, FALSE },
   { "date", XmltvTags_SetVersion5_ByAttr, FALSE },
};

// ----------------------------------------------------------------------------

static const XML_TAGDEF xmltv_tag_def[] =
{
   // DTD 0.5
   { XMLTV5_TOP, "*root/dtd-0.5*", XML_CHILDS(xmltv5_tags_top), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_NO_ATTR,
   },
   { XMLTV5_TV, "tv", XML_CHILDS(xmltv5_tags_tv), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_ATTR(xmltv5_attr_tv),
   },
   { XMLTV5_CHANNEL, "channel", XML_CHILDS(xmltv5_tags_channel), XML_NO_PCDATA,
     { Xmltv_ChannelCreate, Xmltv_ChannelClose, NULL, NULL },
     XMLTV_ATTR(xmltv5_attr_channel),
   },
   { XMLTV5_CHN_DISP_NAME, "display-name", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_ChannelAddName, NULL },
     XMLTV_ATTR(xmltv5_attr_disp_name),
   },
   { XMLTV5_CHN_ICON, "icon", XML_NO_CHILDS, XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_ATTR(xmltv5_attr_icon),
   },
   { XMLTV5_CHN_URL, "url", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_ChannelAddUrl, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PROG, "programme", XML_CHILDS(xmltv5_tags_programme), XML_NO_PCDATA,
     { Xmltv_TsOpen, Xmltv_TsClose, NULL, NULL /*Xmltv_TsFilter*/ },
     XMLTV_ATTR(xmltv5_attr_prog),
   },
   { XMLTV5_PI_TITLE, "title", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiTitleAdd, NULL },
     XMLTV_ATTR(xmltv5_attr_lang_only),
   },
   { XMLTV5_PI_TITLE2, "sub-title", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiEpisodeTitleAdd, NULL },
     XMLTV_ATTR(xmltv5_attr_lang_only),
   },
   { XMLTV5_PI_DESC, "desc", XML_NO_CHILDS, XML_HAS_PCDATA,
     { Xmltv_PiDescOpen, Xmltv_PiDescClose, Xmltv_ParagraphAdd, NULL },
     XMLTV_ATTR(xmltv5_attr_lang_only),
   },
   { XMLTV5_PI_CREDITS, "credits", XML_CHILDS(xmltv5_tags_credits), XML_NO_PCDATA,
     { Xmltv_PiCreditsOpen, Xmltv_PiCreditsClose, NULL, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_DIR, "director", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddDirector, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_ACT, "actor", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddActor, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_WRI, "writer", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddWriter, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_ADAP, "adapter", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddAdapter, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_PROD, "producer", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddProducer, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_PRES, "presenter", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddPresenter, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_COMM, "commentator", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddCommentator, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CRED_GUEST, "guest", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiCreditsAddGuest, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_DATE, "date", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiDateAdd, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_CAT, "category", XML_NO_CHILDS, XML_HAS_PCDATA,
     { Xmltv_PiCatOpen, Xmltv_PiCatClose, Xmltv_PiCatAddText, NULL },
     XMLTV_ATTR(xmltv5_attr_lang_only),
   },
   { XMLTV5_PI_VIDEO, "video", XML_CHILDS(xmltv5_tags_video), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_VIDEO_ASPECT, "aspect", XML_NO_CHILDS, XML_HAS_PCDATA,
     { Xmltv_PiVideoAspectOpen, Xmltv_PiVideoAspectClose, Xmltv_PiVideoAspectAddXY, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_VIDEO_COLOUR, "colour", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiVideoColourAdd, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_VIDEO_QUALITY, "quality", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiVideoQualityAdd, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_AUDIO, "audio", XML_CHILDS(xmltv5_tags_audio), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_AUDIO_STEREO, "stereo", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiAudioStereoAdd, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_SUBT, "subtitles", XML_NO_CHILDS, XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_ATTR(xmltv5_attr_pi_subt),
   },
   { XMLTV5_PI_PRAT, "rating", XML_CHILDS(xmltv5_tags_prat), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_ATTR(xmltv5_attr_pi_prat),
   },
   { XMLTV5_PI_PRAT_VAL, "value", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiRatingAddText, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_ERAT, "star-rating", XML_CHILDS(xmltv5_tags_erat), XML_NO_PCDATA,
     { Xmltv_PiStarRatingOpen, Xmltv_PiStarRatingClose, NULL, NULL },
     XMLTV_NO_ATTR,
   },
   { XMLTV5_PI_ERAT_VAL, "value", XML_NO_CHILDS, XML_HAS_PCDATA,
     { NULL, NULL, Xmltv_PiStarRatingAddText, NULL },
     XMLTV_NO_ATTR,
   },
   // format detection
   { XMLTV_DETECT, "*auto-detect*", XML_CHILDS(xmltv_auto_detect), XML_DISCARD_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_NO_ATTR
   },
   { XMLTV_DETECT_TV, "tv", XML_CHILDS(xmltv_auto_detect_tv), XML_NO_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_ATTR(xmltv_auto_detect_attr_tv)
   },
   { XMLTV_DETECT_PROG, "programme", XML_NO_CHILDS, XML_NO_PCDATA,
     { XmltvTags_SetVersion5_ByTag, NULL, NULL, NULL },
     XMLTV_NO_ATTR
   },
   { XMLTV_SKIP, "*skip*", XML_NO_CHILDS, XML_DISCARD_PCDATA,
     XMLTV_NO_OPEN_CLOSE_CB,
     XMLTV_NO_ATTR
   }
};

// ----------------------------------------------------------------------------
// Check consistency of the above table
//
static void XmltvScan_CheckTablesConsistency( void )
{
#ifdef DEBUG_SWITCH
   uint  tagIdx;
   uint  childIdx;
   bool  refTable[XMLTV_TAG_COUNT];

   assert(sizeof(xmltv_tag_def) == sizeof(xmltv_tag_def[0]) * XMLTV_TAG_COUNT);
   memset(refTable, 0, sizeof(refTable));

   for (tagIdx = 0; tagIdx < XMLTV_TAG_COUNT; tagIdx++)
   {
      assert(xmltv_tag_def[tagIdx].tagIdx == tagIdx);
      assert(xmltv_tag_def[tagIdx].pTagName != NULL);

      // check child references
      assert((xmltv_tag_def[tagIdx].childCount == 0) || (xmltv_tag_def[tagIdx].pChilds != NULL));
      if ((xmltv_tag_def[tagIdx].childCount == 0) && (xmltv_tag_def[tagIdx].pChilds != NULL))
         debug2("CheckTables: Warning state %d (tag '%s') with 0 childs but non-NULL child table", tagIdx, xmltv_tag_def[tagIdx].pTagName);
      for (childIdx = 0; childIdx < xmltv_tag_def[tagIdx].childCount; childIdx++)
      {
         assert(xmltv_tag_def[tagIdx].pChilds[childIdx] < XMLTV_TAG_COUNT);
         refTable[ xmltv_tag_def[tagIdx].pChilds[childIdx] ] += 1;
      }
      if ( (xmltv_tag_def[tagIdx].hasPcData != XML_NO_PCDATA) &&
           (xmltv_tag_def[tagIdx].hasPcData != XML_DISCARD_PCDATA) &&
           (xmltv_tag_def[tagIdx].cb.AddContent == NULL) )
         debug2("CheckTables: Warning state %d (tag '%s') has no callback for PCDATA", tagIdx, xmltv_tag_def[tagIdx].pTagName);
      else if ( (xmltv_tag_def[tagIdx].hasPcData == XML_NO_PCDATA) &&
           (xmltv_tag_def[tagIdx].cb.AddContent != NULL) )
         debug2("CheckTables: Warning state %d (tag '%s') PCDATA callback is disabled", tagIdx, xmltv_tag_def[tagIdx].pTagName);

      // check attributes
      assert((xmltv_tag_def[tagIdx].at.attrCount == 0) || (xmltv_tag_def[tagIdx].at.pTagAttr != NULL));
      if ((xmltv_tag_def[tagIdx].at.attrCount == 0) && (xmltv_tag_def[tagIdx].at.pTagAttr != NULL))
         debug2("CheckTables: Warning state %d (tag '%s') with 0 attributes but non-NULL attribute table", tagIdx, xmltv_tag_def[tagIdx].pTagName);
   }
   for (tagIdx = 0; tagIdx < XMLTV_TAG_COUNT; tagIdx++)
   {
      if ( (refTable[tagIdx] == 0) &&
           (tagIdx != XMLTV5_TOP) &&
           (tagIdx != XMLTV_DETECT) &&
           (tagIdx != XMLTV_SKIP) )
         debug2("CheckTables: Warning state %d (tag '%s') never referenced", tagIdx, xmltv_tag_def[tagIdx].pTagName);
   }
#endif // DEBUG_SWITCH
}

// ----------------------------------------------------------------------------
// Internal parser stack
//
#define XML_STACK_MAX_DEPTH   20
#define XML_SKIP_ATTRIB       (~0)
#define XML_MAX_SYNTAX_ERR    10

#define XML_ADD_DETECTED(V,B) ((V) = (XMLTV_DETECTION)((V) | (B)))

typedef struct
{
   XMLTV_TAG            tagStack[XML_STACK_MAX_DEPTH];
   XML_LANG_CODE        lang[XML_STACK_MAX_DEPTH];
   uint                 stackIdx;
   uint                 syntaxError;
   bool                 earlyStop;
   uint                 xmlAttrToken;
   XML_ENCODING         encoding;
   XMLTV_DETECTION      detected;
} XML_PARSER_STATE;

static XML_PARSER_STATE xps;

// ----------------------------------------------------------------------------
// Parse language code
// - this is a callback function for the "lang" and "xml:lang" attributes
// - implemented here to support inheritage to child elements
// - expects language codes in RFC 1766 style; only the language itself is
//   evaluated, possible dialect or country tags are ignored
//
static void XmltvTags_SetLanguage( XML_STR_BUF * pBuf )
{
   const char * pStr;
   uint  idx;
   XML_LANG_CODE code;

   pStr = XML_STR_BUF_GET_STR(*pBuf);
   code = 0;

   for (idx = 0; idx < 4; idx++)
   {
      if ((*pStr >= 'a') && (*pStr <= 'z'))
         code = (code << 8) | (*pStr - 'a' + 'A');
      else if ((*pStr >= 'A') && (*pStr <= 'Z'))
         code = (code << 8) | *pStr;
      else
         break;

      pStr++;
   }

   xps.lang[xps.stackIdx] = code;
}

// ----------------------------------------------------------------------------
// Query the language of the current element's content
// 
XML_LANG_CODE XmltvTags_GetLanguage( void )
{
   return xps.lang[xps.stackIdx];
}

// ----------------------------------------------------------------------------
// Push new tag on parser stack
// 
void XmltvTags_Open( const char * pTagName )
{
   const XMLTV_TAG  * pChild;
   XMLTV_TAG  state;
   uint  childIdx;
   bool  found;

   if (xps.stackIdx + 1 < XML_STACK_MAX_DEPTH)
   {
      state = xps.tagStack[xps.stackIdx];
      found = FALSE;

      pChild = xmltv_tag_def[state].pChilds;
      for (childIdx = 0; childIdx < xmltv_tag_def[state].childCount; childIdx++)
      {
         if (strcmp(xmltv_tag_def[*pChild].pTagName, pTagName) == 0)
         {
            found = TRUE;
            break;
         }
         pChild++;
      }

      if (found)
      {
         dprintf2("XmltvTag-Open: <%s> inside <%s>\n", pTagName, xmltv_tag_def[state].pTagName);
         xps.stackIdx += 1;
         xps.tagStack[xps.stackIdx] = *pChild;
         xps.xmlAttrToken = XML_SKIP_ATTRIB;
         xps.syntaxError = 0;

         xps.lang[xps.stackIdx] = XML_LANG_UNKNOWN;

         state = *pChild;
         if (xmltv_tag_def[state].cb.TagOpen != NULL)
         {
            xmltv_tag_def[state].cb.TagOpen();
         }
      }
      else
      {
         dprintf2("XmltvTag-Open: ignore <%s> inside <%s>\n", pTagName, xmltv_tag_def[state].pTagName);
         if ((xps.stackIdx == 0) && (xps.syntaxError == 0))
         {
            Xmltv_SyntaxError("XMLTV toplevel tag is not <tv> - probably not an XMLTV document", pTagName);
            XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_NOT_TV);
         }
         xps.stackIdx += 1;
         xps.tagStack[xps.stackIdx] = XMLTV_SKIP;
      }
   }
   else
   {  // abort: stack overflow (the current tag is discarded, which will cause more errors)
      Xmltv_SyntaxError("XMLTV parser fatal error: tags nested too deply", pTagName);
   }
}

// ----------------------------------------------------------------------------
// Pop tag from parser stack
// - tag name can be NULL for empty tags (e.g. <stereo />)
// - returns FALSE if the document top-level tag is closed
//
bool XmltvTags_Close( const char * pTagName )
{
   XMLTV_TAG  state;

   if (xps.stackIdx > 0)
   {
      state = xps.tagStack[xps.stackIdx];

      if (state != XMLTV_SKIP)
      {
         if ( (pTagName == NULL) ||
              (strcmp(xmltv_tag_def[state].pTagName, pTagName) == 0) )
         {
            if (pTagName != NULL)
            {
               dprintf2("XmltvTag-Close: </%s>, new stack depth %d\n", pTagName, xps.stackIdx - 1);
               xps.syntaxError = 0;
            }

            if (xmltv_tag_def[state].cb.TagClose != NULL)
            {
               xmltv_tag_def[state].cb.TagClose();
            }

            xps.stackIdx -= 1;
            state = xps.tagStack[xps.stackIdx];
         }
         else
         {
            Xmltv_SyntaxError("XMLTV parser error: mismatching closing tag", pTagName);
         }
      }
      else
      {
         // FIXME should still compare tag names
         dprintf1("XmltvTag-Close: popping SKIP, new stack depth %d\n", xps.stackIdx - 1);
         xps.stackIdx -= 1;
      }
   }
   else
   {
      Xmltv_SyntaxError("XMLTV parser error: unexpected closing tag", pTagName);
   }

   return (xps.stackIdx > 0);
}

// ----------------------------------------------------------------------------
// Processe PCDATA inbetween open and close tag
//
void XmltvTags_Data( XML_STR_BUF * pBuf )
{
   XMLTV_TAG  state;

   dprintf1("XmltvTag-Data: '%s'\n", XML_STR_BUF_GET_STR(*pBuf));

   state = xps.tagStack[xps.stackIdx];

   if ( (xmltv_tag_def[state].hasPcData != XML_NO_PCDATA) &&
        (xmltv_tag_def[state].hasPcData != XML_DISCARD_PCDATA) )
   {
      if (xmltv_tag_def[state].hasPcData != XML_PCDATA_UNSTRIPPED)
      {
         XmlCdata_TrimWhitespace(pBuf);
      }

      XML_STR_BUF_SET_LANG(*pBuf, xps.lang[xps.stackIdx]);

      if (xmltv_tag_def[state].cb.AddContent != NULL)
      {
         xmltv_tag_def[state].cb.AddContent(pBuf);
      }
   }
}

// ----------------------------------------------------------------------------
// Notify that opening tag is closed, i.e. all attributes processed
// - when the callback returns FALSE, it's content and child elements are skipped;
//   this is an optimization for skipping tags which fall outside certain criteria
// - note this function is currently not called for empty tags, i.e. when the
//   has no childs nor content
//
bool XmltvTags_AttribsComplete( void )
{
   XMLTV_TAG  state;
   bool result = TRUE;

   state = xps.tagStack[xps.stackIdx];

   if (xmltv_tag_def[state].cb.PostAttr != NULL)
   {
      if ( xmltv_tag_def[state].cb.PostAttr() == FALSE )
      {
         // change into the "skip" state, as if the current tag was unknown
         xps.tagStack[xps.stackIdx] = XMLTV_SKIP;
         result = FALSE;
      }
   }
   return result;
}

// ----------------------------------------------------------------------------
// Identify a tag's attribute by its name
//
void XmltvTags_AttribIdentify( const char * pName )
{
   const XMLTV_ATTS * pAttrib;
   XMLTV_TAG  state;
   uint  attrIdx;
   bool  found;

   state = xps.tagStack[xps.stackIdx];
   pAttrib = xmltv_tag_def[state].at.pTagAttr;
   found = FALSE;

   if (pAttrib != NULL)
   {
      for (attrIdx = 0; attrIdx < xmltv_tag_def[state].at.attrCount; attrIdx++)
      {
         if (strcmp(pAttrib->pName, pName) == 0)
         {
            dprintf3("XmltvTag-Attrib: '%s' (%d) for '%s'\n", pName, attrIdx, xmltv_tag_def[state].pTagName);
            found = TRUE;
            break;
         }
         pAttrib++;
      }

      if (found == FALSE)
      {
         dprintf2("XmltvTag-AttribIdentify: ignore '%s' inside '%s'\n", pName, xmltv_tag_def[state].pTagName);
         attrIdx = XML_SKIP_ATTRIB;
      }
   }
   else
      attrIdx = XML_SKIP_ATTRIB;

   xps.xmlAttrToken = attrIdx;
}

// ----------------------------------------------------------------------------
// Process an attribute's data
// - data is already normalized by scanner according to XML 1.0 ch. 3.3.3
//   i.e. entity references are resolved and newline chars replaced by blank
// - TODO: for non-CDATA remove leading space and reduce multiple whitespace into one
//
void XmltvTags_AttribData( XML_STR_BUF * pBuf )
{
   const XMLTV_ATTS * pAttrib;
   XMLTV_TAG  state;

   state = xps.tagStack[xps.stackIdx];
   if (xps.xmlAttrToken < xmltv_tag_def[state].at.attrCount)
   {
      pAttrib = xmltv_tag_def[state].at.pTagAttr + xps.xmlAttrToken;

      dprintf2("XmltvTag-AttribData: assign value '%s' to attrib '%s'\n", XML_STR_BUF_GET_STR(*pBuf), pAttrib->pName);

      XML_STR_BUF_SET_LANG(*pBuf, XML_LANG_UNKNOWN);

      if (pAttrib->SetAttr != NULL)
      {
         pAttrib->SetAttr(pBuf);
      }

      // invalidate attribute: to be used only once
      xps.xmlAttrToken = XML_SKIP_ATTRIB;
   }
   else
      dprintf1("XmltvTag-AttribData: discard attrib value '%s'\n", XML_STR_BUF_GET_STR(*pBuf));
}

// ----------------------------------------------------------------------------
// Scanner callback when an unsupported encoding is encountered
//
void XmltvTags_ScanUnsupEncoding( const char * pName )
{
   Xmltv_SyntaxError("Unsupported encoding", pName);
   XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_UNSUP_ENC);
}

// ----------------------------------------------------------------------------
// Process XML header <?xml version="..." encoding="..."?>
//
void XmltvTags_Encoding( const char * pName )
{
   uint  page, nchar;
   bool result;

   if ( (strcasecmp(pName, "ascii") == 0) ||
        (strcasecmp(pName, "us-ascii") == 0) )
   {
      xps.encoding = XML_ENC_ISO8859_1;
   }
   else if ( (sscanf(pName, "%*[iI]%*[sS]%*[oO]8859%*[_-]%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "%*[iI]%*[sS]%*[oO]8859%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "%*[iI]%*[sS]%*[oO]%*[_-]8859%*[_-]%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "%*[iI]%*[sS]%*[oO]%*[_-]8859%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "%*[iI]%*[sS]%*[oO]8859%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "8859%*[_-]%u%n", &page, &nchar) >= 1) )
   {
      switch (page)
      {
         case 1:  xps.encoding = XML_ENC_ISO8859_1; break;
         case 2:  xps.encoding = XML_ENC_ISO8859_2; break;
         case 5:  xps.encoding = XML_ENC_ISO8859_5; break;
         case 7:  xps.encoding = XML_ENC_ISO8859_7; break;
         case 8:  xps.encoding = XML_ENC_ISO8859_8; break;
         case 9:  xps.encoding = XML_ENC_ISO8859_9; break;
         case 10: xps.encoding = XML_ENC_ISO8859_10; break;
         case 15: xps.encoding = XML_ENC_ISO8859_15; break;
         default: /* nothing */ break;
      }
   }
   else if ( (sscanf(pName, "%*[lL]%*[aA]%*[tT]%*[iI]%*[nN]%*[_-]%u%n", &page, &nchar) >= 1) ||
             (sscanf(pName, "%*[lL]%*[aA]%*[tT]%*[iI]%*[nN]%u%n", &page, &nchar) >= 1) )
   {
      // note: "latin-X" codes are not 1:1 equivalent to ISO-8859 code pages
      switch (page)
      {
         case 1:  xps.encoding = XML_ENC_ISO8859_1; break;   // Western Europe
         case 2:  xps.encoding = XML_ENC_ISO8859_2; break;   // Eastern Europe
         case 5:  xps.encoding = XML_ENC_ISO8859_9; break;   // Turkish
         case 6:  xps.encoding = XML_ENC_ISO8859_10; break;  // Nordic
         case 9:  xps.encoding = XML_ENC_ISO8859_15; break;  // Western Europe, updated
         default: /* nothing */ break;
      }
   }
   else if (strcasecmp(pName, "latin-cyrillic") == 0)
   {
      xps.encoding = XML_ENC_ISO8859_5;
   }
   else if (strcasecmp(pName, "latin-greek") == 0)
   {
      xps.encoding = XML_ENC_ISO8859_7;
   }
   else if (strcasecmp(pName, "latin-hebrew") == 0)
   {
      xps.encoding = XML_ENC_ISO8859_8;
   }
   else if ( (strcasecmp(pName, "utf8") == 0) ||
             (strcasecmp(pName, "utf-8") == 0) )
   {
      xps.encoding = XML_ENC_UTF8;
   }
   else if ( (strcasecmp(pName, "utf16") == 0) ||
             (strcasecmp(pName, "utf-16") == 0) ||
             (strcasecmp(pName, "utf16be") == 0) ||
             (strcasecmp(pName, "utf-16be") == 0) )
   {
      xps.encoding = XML_ENC_UTF16BE;
   }
   else if ( (strcasecmp(pName, "utf16le") == 0) ||
             (strcasecmp(pName, "utf-16le") == 0) )
   {
      xps.encoding = XML_ENC_UTF16LE;
   }

   XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_XML);

   if (xps.encoding != XML_ENC_UNKNOWN)
   {
      result = XmlScan_SetEncoding(xps.encoding);
      if (result == FALSE)
      {
         Xmltv_SyntaxError("Encoding in <?xml?> mismatches auto-detected encoding", pName);
         XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_UNSUP_XMLENC);
      }
   }
   else
   {
      Xmltv_SyntaxError("Unsupported encoding in <?xml?>", pName);
      XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_UNSUP_XMLENC);
      result = FALSE;
   }
}

void XmltvTags_XmlVersion( const char * pVersion )
{
   if (strcmp(pVersion, "1.0") != 0)
   {
      Xmltv_SyntaxError("Incompatible XML version", pVersion);
   }
   else
      XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_XML);
}

// ----------------------------------------------------------------------------
// Process <!DOCTYPE...> declaration
//
void XmltvTags_DocType( const char * pName )
{
   if (strcmp(pName, "tv") != 0)
   {
      Xmltv_SyntaxError("XML DOCTYPE name mismatch (probably not an XMLTV document)", pName);
      XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_NOT_TV);
   }
   XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_DOCTYPE);
}

// ----------------------------------------------------------------------------
// Prolog callbacks - only used during verification (see xml_verify.c)
//
void XmltvTags_PiTarget( const char * pName )
{
}

void XmltvTags_PiContent( const char * pValue )
{
}

void XmltvTags_DocIntDtdClose( void )
{
}

void XmltvTags_Notation( int stepIdx, const char * pValue )
{
}

void XmltvTags_CheckName( const char * pStr )
{
}

void XmltvTags_CheckCharset( const char * pStr )
{
}

void XmltvTags_CheckNmtoken( const char * pStr )
{
}

void XmltvTags_CheckSystemLiteral( const char * pStr )
{
}

// ----------------------------------------------------------------------------
// Return a human-redable error message
// - the "detection" code is a bit-field which is returned by the parser after
//   reading (or attempting to read) the first tags of a document during XMLTV
//   DTD version auto-detection
//
const char * XmltvTags_TranslateErrorCode( XMLTV_DETECTION detection )
{
   const char * pMsg;

   if ((detection == 0) || (detection == XMLTV_DETECTED_SYNTAX))
   {
      pMsg = "does not appear to be an XML document (no markup found)";
   }
   else if (detection & XMLTV_DETECTED_UNSUP_ENC)
   {
      pMsg = "cannot be read because the character encoding is not supported";
   }
   else if (detection & XMLTV_DETECTED_UNSUP_XMLENC)
   {
      pMsg = "is an XML document with an unsupported character encoding";
   }
   else if (detection & XMLTV_DETECTED_NOT_TV)
   {
      pMsg = "is an XML document, but appearently not XMLTV (doctype mismatch)";
   }
   else if (detection & XMLTV_DETECTED_SYNTAX)
   {
      pMsg = "is not an XMLTV document or not valid (parse errors)";
   }
   else
   {
      pMsg = "is not an XMLTV document or incomplete (no content found)";
   }
   return pMsg;
}

// ----------------------------------------------------------------------------
// Notification about syntax error
//
void Xmltv_SyntaxError( const char * pMsg, const char * pStr )
{
   debug2("Xmltv-SyntaxError: %s: '%.200s'", pMsg, pStr);
   XML_ADD_DETECTED(xps.detected, XMLTV_DETECTED_SYNTAX);
   xps.syntaxError += 1;

   if (xps.syntaxError > XML_MAX_SYNTAX_ERR)
   {
      debug0("Xmltv-SyntaxError: too many errors - aborting");
      xps.earlyStop = TRUE;
      XmlScan_Stop();
   }
}

// ----------------------------------------------------------------------------
// Function called by scanner upon I/O or malloc failures
// - ideally this function should raise an exception and not return, else
//   the scanner might run into a NULL pointer dereference
//
void Xmltv_ScanFatalError( const char * pMsg )
{
   debug1("Xmltv-ScanFatalError: %s", pMsg);
}

// ----------------------------------------------------------------------------
// Callback functions for DTD version auto-detection mode
// - in this mode the XML file is parsed (and all data discarded) until a tag
//   or attribute is found which only exists in one of the DTD versions
// - main difficutly is to detect the version also for near-empty files, e.g.
//   a file without programme data (or even with 0 channels, which is legal
//   for DTD 0.5)
//
static void XmltvTags_SetVersion5_ByTag( void )
{
   dprintf0("XmltvTags-SetVersion5: DTD version 5 auto-detected\n");
   xps.earlyStop = TRUE;

   // stop the scanner, i.e. skip the rest of the input file
   XmlScan_Stop();
}

static void XmltvTags_SetVersion5_ByAttr( XML_STR_BUF * pBuf )
{
   XmltvTags_SetVersion5_ByTag();
}

// ----------------------------------------------------------------------------
// Function called by database front-end to discard the rest of input
// - for example, used in "preview" mode when only source info and channel table
//   are read
//
void XmlTags_ScanStop( void )
{
   xps.earlyStop = TRUE;
   XmlScan_Stop();
}

// ----------------------------------------------------------------------------
// Query "detection code" is returned:
// - in case loading XMLTV fails, this can be used to check if the file looks
//   like XML at all to produce an appropriate error message
//
XMLTV_DETECTION XmltvTags_QueryDetection( void )
{
   return xps.detected;
}

// ----------------------------------------------------------------------------
// Initialize and start the parser and scanner
//
void XmltvTags_StartScan( FILE * fp, bool load )
{
   XmltvScan_CheckTablesConsistency();

   XmlScan_Init();

   // push initial state on the element stack
   xps.tagStack[0] = load ? XMLTV5_TOP : XMLTV_DETECT;
   xps.stackIdx = 0;
   xps.detected = XMLTV_DETECTED_OK;
   xps.encoding = XML_ENC_UNKNOWN;

   yyin = fp;
   //yylex();  // called by yacc

   yyparse();

   // check if all tags were closed, i.e. if the stack is empty
   if ((xps.stackIdx > 0) && (xps.earlyStop == FALSE))
   {
      XMLTV_TAG  state;
      state = xps.tagStack[xps.stackIdx];
      debug1("XmltvTag-StartScan: at end-of-file: tag not closed: '%s'", xmltv_tag_def[state].pTagName);
      xps.syntaxError = TRUE;
   }
   XmlScan_Destroy();
}
