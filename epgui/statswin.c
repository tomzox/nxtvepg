/*
 *  Nextview EPG GUI: Database statistics and main window status line
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License Version 2 as
 *  published by the Free Software Foundation. You find a copy of this
 *  license in the file COPYRIGHT in the root directory of this release.
 *
 *  THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 *  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *
 *  Description:
 *
 *    Implements pop-up windows with statistics about the current state
 *    of the databases and the acquisition process.  They can be opened
 *    separately for the browser and acquisition database and are updated
 *    dynamically while acquisition is running.
 *
 *    The statistics window is generated by Tcl/Tk procedures. It consists
 *    of two vertically separated parts: the upper part contains db stats,
 *    such as number of PI in db, percentage of expired PI etc. The lower
 *    part describes the acq state, e.g. number of received blocks etc.
 *    Both parts consist of a canvas widget (graphics output) at the left
 *    and a message widget (multi-line, fixed-width string output) at the
 *    right.
 *
 *    This module also generates the status line at the bottom of the
 *    main window, which is a single line of text which is assembled from
 *    carefully selected db stats and acq state information.
 *
 *  Author: Tom Zoerner
 *
 *  $Id: statswin.c,v 1.80 2020/06/17 19:32:20 tom Exp tom $
 */

#define DEBUG_SWITCH DEBUG_SWITCH_EPGUI
#define DPRINTF_OFF

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <tcl.h>
#include <tk.h>

#include "epgctl/mytypes.h"
#include "epgctl/debug.h"

#include "epgvbi/ttxdecode.h"
#include "epgdb/epgblock.h"
#include "epgdb/epgdbfil.h"
#include "epgdb/epgdbif.h"
#include "epgctl/epgacqctl.h"
#include "epgctl/epgscan.h"
#include "epgctl/epgctxmerge.h"
#include "epgctl/epgacqclnt.h"
#include "epgui/wintvcfg.h"
#include "epgui/menucmd.h"
#include "epgui/epgsetup.h"
#include "epgui/epgmain.h"
#include "epgui/cmdline.h"
#include "epgui/uictrl.h"
#include "epgui/statswin.h"


// state of DbStatsWin window
static struct
{
   bool   open;
   bool   isForAcq;
   int    lastHistPos;
   time_t lastHistReset;
   Tcl_TimerToken updateHandler;
} dbStatsWinState;

//#define STATS_WIN_DB_WNAM   ".dbstats_ui"
#define STATS_WIN_TTX_WNAM  ".dbstats_ttx"

static struct
{
   bool   open;
   Tcl_TimerToken updateHandler;
} statsWinTtx;


static void StatsWin_UpdateDbStatsWinTimeout( ClientData clientData );

// ----------------------------------------------------------------------------
// Update the history diagram in the db statistics window
//
static void StatsWin_UpdateHist( void )
{
   EPG_ACQ_STATS sv;
   uint idx;

   if ( EpgAcqCtl_GetAcqStats(&sv) )
   {
      if (dbStatsWinState.lastHistReset != sv.acqStartTime)
      {  // acquisition was reset -> clear history
         dbStatsWinState.lastHistReset = sv.acqStartTime;
         dbStatsWinState.lastHistPos   = STATS_HIST_WIDTH;

         if (dbStatsWinState.lastHistReset != 0)
         {
            eval_check(interp, "DbStatsWin_ClearHistory .dbstats_ui\n");
         }
      }

      if ( (dbStatsWinState.lastHistPos != sv.histogram.histIdx) &&
           (sv.histogram.histIdx > 1) &&
           (sv.histogram.histIdx != STATS_HIST_WIDTH - 1) )
      {
         idx = (dbStatsWinState.lastHistPos + 1) % STATS_HIST_WIDTH;

         for (idx=0; idx < sv.histogram.histIdx; idx++)
         {
            sprintf(comm, "DbStatsWin_AddHistory .dbstats_ui %d %d %d %d %d %d\n",
                          idx+1,
                          sv.histogram.hist[idx].expir,
                          sv.histogram.hist[idx].s1cur, sv.histogram.hist[idx].s1old,
                          sv.histogram.hist[idx].s2cur, sv.histogram.hist[idx].s2old);
            eval_check(interp, comm);
         }
         dbStatsWinState.lastHistPos = sv.histogram.histIdx;
      }
   }
   else
   {  // acq not running -> clear history
      sprintf(comm, "DbStatsWin_ClearHistory .dbstats_ui\n");
      eval_check(interp, comm);
   }
}

// ----------------------------------------------------------------------------
// Fill window with database statistics and pie chart
//
static void StatsWin_PrintDbStats( EPGDB_CONTEXT * dbc, EPGDB_BLOCK_COUNT * count )
{
   const AI_BLOCK *pAi;
   time_t lastAiUpdate;
   char  provname[60+1], datestr[25+1];
   uint  allVersionsCount, curVersionCount, obsolete;
   uint  netwopCount;
   Tcl_DString cmd_dstr;

   // default values if database is empty
   strcpy(provname, "none yet");
   strcpy(datestr, "none yet");
   netwopCount = 0;

   if (dbc != NULL)
   {  // get provider name and db version from AI block
      EpgDbLockDatabase(dbc, TRUE);
      pAi = EpgDbGetAi(dbc);
      if (pAi != NULL)
      {
         strncpy(provname, AI_GET_SERVICENAME(pAi), sizeof(provname) - 1);
         provname[sizeof(provname) - 1] = 0;
         lastAiUpdate = EpgDbGetAiUpdateTime(dbc);
         strftime(datestr, 25, "%H:%M:%S %a %d.%m.", localtime(&lastAiUpdate));
         netwopCount = pAi->netwopCount;
      }
      EpgDbLockDatabase(dbc, FALSE);
   }

   obsolete         = count->expired + count->defective;
   allVersionsCount = count->allVersions + obsolete;
   curVersionCount  = count->curVersion + obsolete;

   sprintf(comm, "EPG provider:     %s\n"
                 "Last update:      %s\n"
                 "Networks in db:   %d\n"
                 "Blocks in db:     %d\n"
                 "Current version:  %d\n"
                 "Expired total:    %d (%d%%)\n"
                 "Defective blocks: %d (%d%%)",
                 provname,
                 datestr,
                 netwopCount,
                 allVersionsCount,
                 curVersionCount,
                 count->expired, ACQ_COUNT_TO_PERCENT(count->expired, allVersionsCount),
                 count->defective, ACQ_COUNT_TO_PERCENT(count->defective, allVersionsCount)
          );
   {
      Tcl_DStringInit(&cmd_dstr);
      Tcl_DStringAppend(&cmd_dstr, ".dbstats_ui", -1);
      Tcl_DStringAppend(&cmd_dstr, ".browser.stat configure -text", -1);
      // append message as list element, so that '{' etc. is escaped properly
      Tcl_DStringAppendElement(&cmd_dstr, comm);

      eval_check(interp, Tcl_DStringValue(&cmd_dstr));

      Tcl_DStringFree(&cmd_dstr);
   }

   if (allVersionsCount > 0)
   {
      uint total = allVersionsCount;  // TODO TTX temporary
      sprintf(comm, "DbStatsWin_PaintPie .dbstats_ui %d %d %d %d\n",
                    (int)((double)(count->defective + count->expired) / total * 359.9),
                    (int)((double)(count->curVersion + count->defective + count->expired) / total * 359.9),
                    (int)((double)(count->allVersions + count->defective + count->expired) / total * 359.9),
                    (int)((double) /*count->ai / total * */ 359.9));
   }
   else
   {
      sprintf(comm, "DbStatsWin_ClearPie .dbstats_ui\n" );
   }
   eval_check(interp, comm);
}

// ----------------------------------------------------------------------------
// Fill window with Nextview acquisition status information
//
static void StatsWin_PrintAcqStats( EPGDB_CONTEXT * dbc, EPGACQ_DESCR * pAcqState,
                                    EPG_ACQ_STATS * sv, EPG_ACQ_VPS_PDC * pVpsPdc )
{
   double ttxRate;
   time32_t acq_duration;
   const char * pAcqModeStr;
   const char * pAcqPasvStr;
   Tcl_DString cmd_dstr;

   comm[0] = 0;

   #ifdef USE_DAEMON
   if (pAcqState->isNetAcq)
   {
      EPGDBSRV_DESCR netState;
      EpgAcqClient_DescribeNetState(&netState);
      switch(netState.state)
      {
         case NETDESCR_ERROR:
            sprintf(comm + strlen(comm), "Network state:    error\nError cause:      %s\n", ((netState.cause != NULL) ? netState.cause : "unknown"));
            break;
         case NETDESCR_CONNECT:
            sprintf(comm + strlen(comm), "Network state:    server contacted\n");
            break;
         case NETDESCR_STARTUP:
            sprintf(comm + strlen(comm), "Network state:    connect in progress\n");
            break;
         case NETDESCR_LOADING:
            sprintf(comm + strlen(comm), "Network state:    loading database\n");
            break;
         case NETDESCR_RUNNING:
            sprintf(comm + strlen(comm), "Network state:    connected (rx %ld bytes)\n", netState.rxTotal);
            break;
         case NETDESCR_DISABLED:
         default:
            sprintf(comm + strlen(comm), "Network state:    unconnected\n");
            break;
      }
   }
   #endif

   if ((sv->acqStartTime > 0) && (sv->acqStartTime <= sv->lastStatsUpdate))
      acq_duration = sv->lastStatsUpdate - sv->acqStartTime;
   else
      acq_duration = 0;

   sprintf(comm + strlen(comm), "Acq Runtime:      %02d:%02d\n",
                                (uint)(acq_duration / 60), (uint)(acq_duration % 60));

   if (pVpsPdc->cni != 0)
   {
      if ( VPS_PIL_IS_VALID(pVpsPdc->pil) )
      {
         sprintf(comm + strlen(comm), "Channel VPS/PDC:  CNI %04X, PIL %02d.%02d. %02d:%02d\n",
                                      pVpsPdc->cni,
                                      (pVpsPdc->pil >> 15) & 0x1F, (pVpsPdc->pil >> 11) & 0x0F,
                                      (pVpsPdc->pil >>  6) & 0x1F, (pVpsPdc->pil) & 0x3F);
      }
      else
      {
         sprintf(comm + strlen(comm), "Channel VPS/PDC:  CNI %04X\n", pVpsPdc->cni);
      }
   }
   else
      strcat(comm, "Channel VPS/PDC:  ---\n");

   ttxRate  =(double)sv->ttx_dec.ttxPkgRate / (1 << TTX_PKG_RATE_FIXP);

   sprintf(comm + strlen(comm),
                 "TTX pkg/frame:    %.1f (%.0f baud)\n",
                 ttxRate, ttxRate * 42 * 8 * 25
          );

   EpgAcqCtl_GetAcqModeStr(pAcqState, /* forTtx := FALSE,*/ &pAcqModeStr, &pAcqPasvStr);
#ifdef WIN32
   if (EpgSetup_CheckTvCardConfig() == FALSE)
   {
      pAcqPasvStr = "TV card not configured";
   }
#endif
   sprintf(comm + strlen(comm), "Acq mode:         %s\n", pAcqModeStr);
   if (pAcqPasvStr != NULL)
      sprintf(comm + strlen(comm), "Passive reason:   %s\n", pAcqPasvStr);

   {
      Tcl_DStringInit(&cmd_dstr);
      Tcl_DStringAppend(&cmd_dstr, ".dbstats_ui", -1);
      Tcl_DStringAppend(&cmd_dstr, ".acq.stat configure -text", -1);
      // append message as list element, so that '{' etc. is escaped properly
      Tcl_DStringAppendElement(&cmd_dstr, comm);

      eval_check(interp, Tcl_DStringValue(&cmd_dstr));

      Tcl_DStringFree(&cmd_dstr);
   }
}

// ----------------------------------------------------------------------------
// Update the database statistics window
// - consists of two parts:
//   + the upper one describes the current state of the database, with a pie chart
//     and statistics of PI block counts against the numbers from the AI block
//   + the lower one describes the current acquisition state and a histroy diagram
//     of current and past PI block count percentages
//
static void StatsWin_UpdateDbStatsWin( ClientData clientData )
{
   EPGDB_BLOCK_COUNT count;
   EPGDB_CONTEXT * dbc;
   EPGACQ_DESCR acqState;
   EPG_ACQ_STATS sv;
   EPG_ACQ_VPS_PDC vpsPdc;
   uint target;

   target = PVOID2UINT(clientData);
   dbc = pUiDbContext;

   if ((target < 2) && dbStatsWinState.open)
   {
      dprintf1("StatsWin-UpdateDbStatsWin: for %s\n", ((target == DB_TARGET_UI) ? "ui" : "acq"));

      // acq not running for this database -> display db stats only
      memset(&count, 0, sizeof(count));
      if (dbc != NULL)
      {
         EpgDbGetStat(dbc, &count, 0);
      }

      // print database statistics and pie chart
      StatsWin_PrintDbStats(dbc, &count);

      if (0) // TODO DB_TARGET_ACQ: check if acq works on GUI DB
      {
         if (EpgAcqCtl_GetAcqStats(&sv) == FALSE)
         {
            memset(&sv, 0, sizeof(sv));
         }
         if (dbStatsWinState.isForAcq == FALSE)
         {
            sprintf(comm, "pack .dbstats_ui.acq -side top -anchor nw -fill both "
                                               "-after .dbstats_ui.browser\n");
            eval_check(interp, comm);
            dbStatsWinState.isForAcq = TRUE;
         }

         EpgAcqCtl_DescribeAcqState(&acqState);

         if (EpgAcqCtl_GetVpsPdc(&vpsPdc, VPSPDC_REQ_STATSWIN, FALSE) == FALSE)
         {
            vpsPdc.cni = 0;
         }

         // display graphical database fill percentage histogramm
         StatsWin_UpdateHist();

         // text description
         StatsWin_PrintAcqStats(dbc, &acqState, &sv, &vpsPdc);

         // remove the old update timer
         if (dbStatsWinState.updateHandler != NULL)
         {
            Tcl_DeleteTimerHandler(dbStatsWinState.updateHandler);
         }
         // set up a timer to re-display the stats in case there's no EPG reception
         if ((acqState.ttxGrabState != ACQDESCR_DISABLED) && (acqState.isNetAcq == FALSE))
         {
            dbStatsWinState.updateHandler =
               Tcl_CreateTimerHandler(10*1000, StatsWin_UpdateDbStatsWinTimeout, NULL);
         }
      }
      else
      {  // acq not running (at least for the same db)
         if (dbStatsWinState.isForAcq)
         {  // acq stats are still being displayed -> remove them
            sprintf(comm, ".dbstats_ui.acq.stat configure -text {}\n"
                          "pack forget .dbstats_ui.acq\n");
            eval_check(interp, comm);

            sprintf(comm, "DbStatsWin_ClearHistory .dbstats_ui\n");
            eval_check(interp, comm);

            dbStatsWinState.isForAcq = FALSE;
         }
      }
   }
}

// ----------------------------------------------------------------------------
// Update the teletext grabber statistics window
//
static void StatsWin_UpdateTtxStats( ClientData clientData )
{
   EPGACQ_DESCR acqState;
   EPG_ACQ_STATS sv;
   EPG_ACQ_VPS_PDC vpsPdc;
   time32_t acq_duration;
   const char * pAcqModeStr;
   const char * pAcqPasvStr;
   Tcl_DString cmd_dstr;

   if (statsWinTtx.open)
   {
      if (EpgAcqCtl_GetAcqStats(&sv) == FALSE)
      {
         memset(&sv, 0, sizeof(sv));
      }

      EpgAcqCtl_DescribeAcqState(&acqState);

      if ((sv.acqStartTime > 0) && (sv.acqStartTime <= sv.lastStatsUpdate))
      {
         acq_duration = sv.lastStatsUpdate - sv.acqStartTime;
      }
      else
         acq_duration = 0;

      EpgAcqCtl_GetAcqModeStr(&acqState, &pAcqModeStr, &pAcqPasvStr);
      if ((pAcqPasvStr != NULL) && (EpgSetup_CheckTvCardConfig() == FALSE))
      {
         pAcqPasvStr = "TV card not configured";
      }

      comm[0] = 0;

      sprintf(comm + strlen(comm), "Acq Runtime:      %02d:%02d\n"
                                   "Acq mode:         %s\n"
                                   "Acq passive:      %s\n"
                                   "Channels done:    %d of %d (%d%%)\n"
                                   "Current channels: %d (concurrent)\n",
                                   (uint)(acq_duration / 60), (uint)(acq_duration % 60),
                                   pAcqModeStr,
                                   ((pAcqPasvStr == NULL) ? "---" : pAcqPasvStr),
                                   acqState.ttxGrabDone, acqState.ttxSrcCount,
                                     ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount),
                                   acqState.ttxGrabCount);

      sprintf(comm + strlen(comm), "Channel name:     %s\n", sv.srcName);

      if (EpgAcqCtl_GetVpsPdc(&vpsPdc, VPSPDC_REQ_STATSWIN, FALSE) && (vpsPdc.cni != 0))
      {
         if ( VPS_PIL_IS_VALID(vpsPdc.pil) )
         {
            sprintf(comm + strlen(comm), "Channel VPS/PDC:  CNI %04X, PIL %02d.%02d. %02d:%02d\n",
                                         vpsPdc.cni,
                                         (vpsPdc.pil >> 15) & 0x1F, (vpsPdc.pil >> 11) & 0x0F,
                                         (vpsPdc.pil >>  6) & 0x1F, (vpsPdc.pil) & 0x3F);
         }
         else
         {
            sprintf(comm + strlen(comm), "Channel VPS/PDC:  CNI %04X\n", vpsPdc.cni);
         }
      }
      else
         strcat(comm, "Channel VPS/PDC:  ---\n");

      sprintf(comm + strlen(comm),
                    "TTX data rate:    %d baud\n"
                    "Captured range:   %03X-%03X\n"
                    "Captured pages:   %d (%d pkg, %1.1f%% of TTX)\n"
                    "Decoder quality:  blanked %d of %d chars (%d%%)\n",
                    ((sv.acqDuration > 0) ? (int)((sv.ttx_dec.ttxPkgCount*45*8)/sv.acqDuration) : 0),
                    sv.pkgStats.ttxPageStartNo,
                       sv.pkgStats.ttxPageStopNo,
                    sv.pkgStats.ttxPagCount,
                       sv.pkgStats.ttxPkgCount,
                       ((sv.ttx_dec.ttxPkgCount > 0) ? ((double)sv.pkgStats.ttxPkgCount*100.0/sv.ttx_dec.ttxPkgCount) : 0.0),
                    sv.pkgStats.ttxPkgParErr, sv.pkgStats.ttxPkgStrSum,
                    ((sv.pkgStats.ttxPkgStrSum > 0) ? (sv.pkgStats.ttxPkgParErr * 100 / sv.pkgStats.ttxPkgStrSum) : 0)
             );

      {
         Tcl_DStringInit(&cmd_dstr);
         Tcl_DStringAppend(&cmd_dstr, STATS_WIN_TTX_WNAM, -1);
         Tcl_DStringAppend(&cmd_dstr, ".acq.stat configure -text", -1);
         // append message as list element, so that '{' etc. is escaped properly
         Tcl_DStringAppendElement(&cmd_dstr, comm);

         eval_check(interp, Tcl_DStringValue(&cmd_dstr));

         Tcl_DStringFree(&cmd_dstr);
      }

      // remove the old update timer
      if (statsWinTtx.updateHandler != NULL)
         Tcl_DeleteTimerHandler(statsWinTtx.updateHandler);
      // set up a timer to re-display the stats in case there's no EPG reception
      if ((acqState.ttxGrabState != ACQDESCR_DISABLED) && (acqState.isNetAcq == FALSE))
         statsWinTtx.updateHandler =
            Tcl_CreateTimerHandler(2*1000, StatsWin_UpdateTtxStats, NULL);
   }
}

// ----------------------------------------------------------------------------
// Schedule update of stats window after timeout
// - used only for stats windows with acquisition
// - timeout occurs when no AI is received
//
static void StatsWin_UpdateDbStatsWinTimeout( ClientData clientData )
{
   dbStatsWinState.updateHandler = NULL;
   AddMainIdleEvent(StatsWin_UpdateDbStatsWin, clientData, FALSE);
}

// ----------------------------------------------------------------------------
// Update status line of browser main window
// - possible bits of information about browser db:
//   + allversion percentage of PI
//   + time & date of last database update
//   + percentage of expired PI
// - possible bits of information about acq:
//   + state: Off, Startup, Running, Stalled
//   + CNI in acq db
//   + mode: forced-passive & reason, passive, cycle state
//
static void StatsWin_UpdateDbStatusLine( ClientData clientData )
{
   EPGDB_BLOCK_COUNT count;
   EPGACQ_DESCR acqState;
   const AI_BLOCK *pAi;
   char * pProvName, provName[40];
   ulong allCount, expiredCount, expiredBase;
   time_t dbAge;
   bool isPassiveAcq;
   #ifdef USE_DAEMON
   EPGDBSRV_DESCR netState;
   #endif

   dprintf0("StatsWin-UpdateDbStatusLine: called\n");

   comm[0] = 0;

   if (EpgDbContextGetCni(pUiDbContext) != 0)
   {
      // compute statistics
      EpgDbGetStat(pUiDbContext, &count, 0);

      // get name of UI provider network
      EpgDbLockDatabase(pUiDbContext, TRUE);
      pAi = EpgDbGetAi(pUiDbContext);
      if (EpgDbContextIsMerged(pUiDbContext))
         sprintf(comm + strlen(comm), "Merged database");
      else if (pAi != NULL)
         sprintf(comm + strlen(comm), "%s database", AI_GET_SERVICENAME(pAi));
      else
         strcat(comm, "Browser database");
      EpgDbLockDatabase(pUiDbContext, FALSE);

      allCount     = count.allVersions + count.expired + count.defective;
      expiredCount = count.expired;
      expiredBase  = count.allVersions + expiredCount;

      // print fill percentage across all db versions
      if ((allCount == 0) || (expiredCount + count.defective >= allCount))
      {
         strcat(comm, " is empty");
      }

      // warn about age of database if more than one hour old
      dbAge = (time(NULL) - EpgDbGetAiUpdateTime(pUiDbContext)) / 60;
      if (dbAge >= 24*60)
      {
         sprintf(comm + strlen(comm), ", %1.1f days old", (double)dbAge / (24*60));
      }
      else if (dbAge >= 10*60)
      {
         sprintf(comm + strlen(comm), ", %ld hours old", (dbAge + 60/2) / 60);
      }

      // print how much of PI are expired
      if ( (expiredBase > 0) && (expiredCount > 0) &&
           ((dbAge >= 60) || (expiredCount * 10 >= expiredBase)) )
      {
         sprintf(comm + strlen(comm), ", %d%% expired", ACQ_COUNT_TO_PERCENT(expiredCount, expiredBase));
      }
      strcat(comm, ". ");
   }

   // fetch current state and acq db statistics from acq control
   EpgAcqCtl_DescribeAcqState(&acqState);
   pProvName = NULL;

   {
      char * pTtxNames = NULL;
      char * pName;
      uint chanCount;
      uint idx;

      if ( WintvCfg_GetFreqTab(&pTtxNames, NULL, &chanCount, NULL) &&
           (acqState.ttxGrabIdx[0] >= 0) && (acqState.ttxGrabIdx[0] < (int)chanCount))
      {
         pName = pTtxNames;
         for (idx = 0; idx < acqState.ttxGrabIdx[0]; idx++)
            while(*(pName++) != 0)
               ;
         strncpy(provName, pName, sizeof(provName) - 1);
         if (strlen(pName) + 9+1 <= sizeof(provName))
            strcat(provName, " teletext");
         else
            strcpy(provName + sizeof(provName) - (12+1), "... teletext");
         pProvName = provName;
      }
      if (pTtxNames != NULL)
         xfree(pTtxNames);
   }


   // describe acq state (disabled, network connect, running)

   #ifdef USE_DAEMON
   if (acqState.isNetAcq)
   {
      if ( EpgAcqClient_DescribeNetState(&netState) )
      {
         // network connection to acquisition server is not set up -> describe network state instead
         switch (netState.state)
         {
            case NETDESCR_CONNECT:
            case NETDESCR_STARTUP:
               strcat(comm, "Acquisition: connecting to server..");
               break;
            case NETDESCR_ERROR:
            case NETDESCR_DISABLED:
               strcat(comm, "Acquisition stalled: network error");
               break;
            case NETDESCR_LOADING:
               strcat(comm, "Acquisition: connecting to server..");
               break;
            case NETDESCR_RUNNING:
               if (acqState.ttxGrabState == ACQDESCR_NET_CONNECT)
               {  // note: in state RUNNING display "loading" until the first stats report is available
                  strcat(comm, "Acquisition: connecting to server..");
               }
               break;
            default:
               fatal1("StatsWin-UpdateDbStatusLine: unknown net state %d", netState.state);
               break;
         }

         if (netState.state != NETDESCR_RUNNING)
         {  // set acq state to suppress additional output (e.g. acq phase)
            acqState.ttxGrabState = ACQDESCR_NET_CONNECT;
         }
      }
   }
   #endif

   isPassiveAcq = (acqState.mode == ACQMODE_PASSIVE) ||
                  (acqState.passiveReason != ACQPASSIVE_NONE);

   // TODO: in passive mode use either source (careful: use matching provname!)
   switch (acqState.ttxGrabState)
   {
      case ACQDESCR_DISABLED:
         strcat(comm, "Acquisition is disabled");
         break;
      case ACQDESCR_NET_CONNECT:
      case ACQDESCR_SCAN:
         break;
      case ACQDESCR_STARTING:
         if ((isPassiveAcq == FALSE) && (pProvName != NULL))
         {
            sprintf(comm + strlen(comm), "Acquisition is starting up for %s", pProvName);
         }
         else
            strcat(comm, "Acquisition is waiting for reception");
         break;
      case ACQDESCR_TTX_PG_SEQ_SCAN:
         strcat(comm, "Acquisition scanning teletext");
         break;
      case ACQDESCR_NO_RECEPTION:
         #ifdef WIN32
         if (EpgSetup_CheckTvCardConfig() == FALSE)
         {
            strcat(comm, "Acquisition: TV card not configured");
         }
         else
         #endif
         if ((isPassiveAcq == FALSE) && (pProvName != NULL))
         {
            sprintf(comm + strlen(comm), "Acquisition: no reception on %s", pProvName);
         }
         else
            strcat(comm, "Acquisition: no teletext reception");
         break;
      case ACQDESCR_IDLE:
         strcat(comm, "Acquisition: idle");
         break;
      case ACQDESCR_RUNNING:
         if (pProvName != NULL)
         {
            sprintf(comm + strlen(comm), "Acquisition working on %s", pProvName);
         }
         else
         {  // internal inconsistancy
            //TODO fatal0("StatsWin-UpdateDbStatusLine: no AI block while in state RUNNING");
            sprintf(comm + strlen(comm), "Acquisition in progress..");
            // patch state to prevent further output
            acqState.ttxGrabState = ACQDESCR_NET_CONNECT;
         }
         break;

      default:
         fatal1("StatsWin-UpdateDbStatusLine: unknown acq state %d", acqState.ttxGrabState);
   }

   // describe acq mode, warn the user if passive
   if ( (acqState.ttxGrabState != ACQDESCR_NET_CONNECT) &&
        (acqState.ttxGrabState != ACQDESCR_DISABLED) &&
        (acqState.ttxGrabState != ACQDESCR_SCAN))
   {
      if (acqState.mode == ACQMODE_PASSIVE)
      {
         strcat(comm, " (passive mode)");
      }
      else if (acqState.passiveReason != ACQPASSIVE_NONE)
      {
         strcat(comm, " (forced passive)");
      }
      else if (acqState.mode == ACQMODE_CYCLIC_2)
      {
         sprintf(comm + strlen(comm), ", overall %d%% complete",
                 ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
      }
      else
      {
         switch (acqState.cyclePhase)
         {
            case ACQMODE_PHASE_NOWNEXT:
               sprintf(comm + strlen(comm), " phase 'Now', %d%% complete",
                       ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
               break;
            case ACQMODE_PHASE_FULL:
               sprintf(comm + strlen(comm), " phase 'Full', %d%% complete",
                       ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
               break;
            case ACQMODE_PHASE_MONITOR:
               sprintf(comm + strlen(comm), " phase 'Complete', %d%% complete",
                       ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
               break;
            default:
               break;
         }
      }
   }

   switch (acqState.ttxGrabState)
   {
      case ACQDESCR_SCAN:
         break;
      case ACQDESCR_STARTING:
      case ACQDESCR_TTX_PG_SEQ_SCAN:
         strcat(comm, "...");
         break;
      default:
         strcat(comm, ".");
         break;
   }

   {
      if (Tcl_SetVar(interp, "dbstatus_line", comm, TCL_GLOBAL_ONLY) == NULL)
      {
         debugTclErr(interp, "assigning to var dbstatus_line");
      }
   }
}

// ----------------------------------------------------------------------------
// Open or close window with db and acq statistics
// - called by the "View (acq) statistics" menu entries (toggle mode, argc=2)
//   or as a callback when a statistics window is destroyed
//
static int StatsWin_ToggleDbStats( ClientData ttp, Tcl_Interp *interp, int argc, CONST84 char *argv[] )
{
   const char * const pUsage = "Usage: C_StatsWin_ToggleDbStats [0|1]";
   int newState;
   int result = TCL_OK;

   if ( (argc < 1) || (argc > 2) ||
        ((argc == 2) && (Tcl_GetBoolean(interp, argv[1], &newState) != TCL_OK)) )
   {
      Tcl_SetResult(interp, (char *)pUsage, TCL_STATIC);
      result = TCL_ERROR;
   }
   else
   {
      result = TCL_OK;

      // determine new state from optional second parameter: 0, 1 or toggle
      if (argc == 1)
      {  // no state parameter -> toggle state
         newState = ! dbStatsWinState.open;
      }

      if (newState != dbStatsWinState.open)
      {
         if (dbStatsWinState.open == FALSE)
         {  // window shall be opened
            sprintf(comm, "DbStatsWin_Create .dbstats_ui\n");
            eval_check(interp, comm);

            dbStatsWinState.open = TRUE;
            dbStatsWinState.isForAcq = FALSE;
            dbStatsWinState.lastHistPos = 0;
            dbStatsWinState.lastHistReset = 0;
            dbStatsWinState.updateHandler = NULL;

            if (0) // TODO DB_TARGET_ACQ: check if acq works on GUI DB
            {
               StatsWin_UpdateHist();
            }
            // enable extended statistics reports
            EpgAcqCtl_EnableAcqStats(TRUE);

            // display initial summary
            StatsWin_UpdateDbStatsWin(NULL);
         }
         else
         {  // destroy the window

            // note: set to FALSE before window destruction to avoid recursion
            dbStatsWinState.open = FALSE;

            sprintf(comm, "destroy .dbstats_ui");
            eval_check(interp, comm);

            // disable extended statistics reports when all windows are closed
            if ( (dbStatsWinState.open == FALSE) &&
                 (statsWinTtx.open == FALSE) )
            {
               EpgAcqCtl_EnableAcqStats(FALSE);
            }
         }
         // set the state of the checkbutton of the respective menu entry
         Tcl_SetVar2Ex(interp, "menuStatusDbStatsOpen", NULL,
                               Tcl_NewIntObj(dbStatsWinState.open), 0);
      }
   }

   return result;
}

// ----------------------------------------------------------------------------
// Open or close window with teletext grabber statistics
//
static int StatsWin_ToggleTtxStats( ClientData ttp, Tcl_Interp *interp, int argc, CONST84 char *argv[] )
{
   const char * const pUsage = "Usage: C_StatsWin_ToggleTtxStats [0|1]";
   int newState;
   int result;

   if ( (argc < 1) || (argc > 2) ||
        ((argc == 2) && (Tcl_GetBoolean(interp, argv[1], &newState) != TCL_OK)) )
   {
      Tcl_SetResult(interp, (char *)pUsage, TCL_STATIC);
      result = TCL_ERROR;
   }
   else
   {
      if (argc == 1)
      {
         newState = ! statsWinTtx.open;
      }

      if (newState != statsWinTtx.open)
      {
         if (statsWinTtx.open == FALSE)
         {  // window shall be opened
            sprintf(comm, "StatsWinTtx_Create %s\n", STATS_WIN_TTX_WNAM);
            eval_check(interp, comm);

            statsWinTtx.open = TRUE;
            statsWinTtx.updateHandler = NULL;

            // enable extended statistics reports
            EpgAcqCtl_EnableAcqStats(TRUE);

            // display initial summary
            StatsWin_UpdateTtxStats(NULL);
         }
         else
         {  // destroy the window

            // note: set to FALSE before window destruction to avoid recursion
            statsWinTtx.open = FALSE;

            sprintf(comm, "destroy %s", STATS_WIN_TTX_WNAM);
            eval_check(interp, comm);

            // disable extended statistics reports when all windows are closed
            if (dbStatsWinState.open == FALSE)
            {
               EpgAcqCtl_EnableAcqStats(FALSE);
            }
         }
         // set the state of the checkbutton of the according menu entry
         Tcl_SetVar2Ex(interp, "menuStatusAcqStatsOpen", NULL,
                               Tcl_NewIntObj(statsWinTtx.open), 0);
      }
      result = TCL_OK;
   }

   return result;
}

// ----------------------------------------------------------------------------
// Schedule an update of all statistics output
// - argument target says which statistics popup needs to be updated.
//   Since the main window status line contains info about both acq and ui db
//   its update is unconditional.
// - the function is triggered by acq control regularily upon every DB update
//   and after provider changes or after acquisition parameters are changed
//   or after a provider change by the user for the browser database
// - the function is also triggered by GUI provider changes
//   plus regularily every minute (to update expiration statistics)
//
void StatsWin_StatsUpdate( int target )
{
   // update the db statistics window of the given db, if open
   if ( (target == DB_TARGET_UI) && dbStatsWinState.open)
   {
      AddMainIdleEvent(StatsWin_UpdateDbStatsWin, UINT2PVOID(target), FALSE);
   }

   if ( (target == DB_TARGET_ACQ) && statsWinTtx.open)
   {
      AddMainIdleEvent(StatsWin_UpdateTtxStats, NULL, TRUE);
   }

   // update the main window status line
   AddMainIdleEvent(StatsWin_UpdateDbStatusLine, NULL, TRUE);
}

// ----------------------------------------------------------------------------
// Initialize module state variables
// - this should be called only once during start-up
//
void StatsWin_Create( void )
{
   Tcl_CmdInfo cmdInfo;

   if (Tcl_GetCommandInfo(interp, "C_StatsWin_ToggleDbStats", &cmdInfo) == 0)
   {
      Tcl_CreateCommand(interp, "C_StatsWin_ToggleDbStats", StatsWin_ToggleDbStats, (ClientData) NULL, NULL);
      Tcl_CreateCommand(interp, "C_StatsWin_ToggleTtxStats", StatsWin_ToggleTtxStats, (ClientData) NULL, NULL);
   }
   else
      fatal0("StatsWin-Create: commands are already created");

   memset(&dbStatsWinState, 0, sizeof(dbStatsWinState));
}

