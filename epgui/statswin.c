/*
 *  Nextview EPG GUI: Database statistics and main window status line
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License Version 2 as
 *  published by the Free Software Foundation. You find a copy of this
 *  license in the file COPYRIGHT in the root directory of this release.
 *
 *  THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 *  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *
 *  Description:
 *
 *    Implements pop-up windows with statistics about the current state
 *    of the databases and the acquisition process.  They can be opened
 *    separately for the browser and acquisition database and are updated
 *    dynamically while acquisition is running.
 *
 *    The statistics window is generated by Tcl/Tk procedures. It consists
 *    of two vertically separated parts: the upper part contains db stats,
 *    such as number of PI in db, percentage of expired PI etc. The lower
 *    part describes the acq state, e.g. number of received blocks etc.
 *    Both parts consist of a canvas widget (graphics output) at the left
 *    and a message widget (multi-line, fixed-width string output) at the
 *    right.
 *
 *    This module also generates the status line at the bottom of the
 *    main window, which is a single line of text which is assembled from
 *    carefully selected db stats and acq state information.
 *
 *  Author: Tom Zoerner
 *
 *  $Id: statswin.c,v 1.80 2020/06/17 19:32:20 tom Exp tom $
 */

#define DEBUG_SWITCH DEBUG_SWITCH_EPGUI
#define DPRINTF_OFF

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <tcl.h>
#include <tk.h>

#include "epgctl/mytypes.h"
#include "epgctl/debug.h"

#include "epgvbi/ttxdecode.h"
#include "epgdb/epgblock.h"
#include "epgdb/epgdbfil.h"
#include "epgdb/epgdbif.h"
#include "epgctl/epgacqctl.h"
#include "epgctl/epgscan.h"
#include "epgctl/epgctxmerge.h"
#include "epgctl/epgacqclnt.h"
#include "epgui/wintvcfg.h"
#include "epgui/menucmd.h"
#include "epgui/epgsetup.h"
#include "epgui/epgmain.h"
#include "epgui/cmdline.h"
#include "epgui/uictrl.h"
#include "epgui/rcfile.h"
#include "epgui/statswin.h"


// ----------------------------------------------------------------------------
// State of the database statistics window

typedef struct
{
   uint32_t  expir;
   uint32_t  day1cur;
   uint32_t  day1old;
   uint32_t  day2cur;
   uint32_t  day2old;
   uint32_t  day3cur;
   uint32_t  day3old;
} STATS_DB_HIST_ELEM;

#define STATS_DB_HIST_WIDTH     128    // histogram canvas width [pixels]
#define STATS_DB_HIST_HEIGHT    128    // histogram canvas height [pixels]
#define STATS_DB_HIST_UPD_FREQ  20     // min. time delta for histogram entries [seconds]
#define STATS_DB_ACQ_UPD_FREQ   10     // update frequency for acq. stats in DB stats window
#define STATS_TTX_UPD_FREQ      2      // update frequency for TTX grabber stats window

static struct
{
   bool     open;
   bool     histShown;
   bool     histNeedsReset;
   uint     histIdx;
   uint     histScaleY;
   time_t   histUpdateTs;
   STATS_DB_HIST_ELEM hist[STATS_DB_HIST_WIDTH];
   Tcl_TimerToken updateHandler;
} dbStatsWinState;

// ----------------------------------------------------------------------------
// State of the teletext grabber statistics window

static struct
{
   bool   open;
   uint   usedCols;
   Tcl_TimerToken updateHandler;
} statsWinTtx;

//#define STATS_WIN_DB_WNAM   ".dbstats_ui"
#define STATS_WIN_TTX_WNAM  ".dbstats_ttx"
#define STATS_WIN_TTX_ROWS  7

static void StatsWin_UpdateDbStatsWinTimeout( ClientData clientData );


// ----------------------------------------------------------------------------
// Helper function for configuring a label to display a given string
// - string content is properly escaped
//
static void StatsWin_ConfigureLabelText( const char * pWidName, const char * pMsg )
{
   Tcl_DString cmd_dstr;

   Tcl_DStringInit(&cmd_dstr);
   Tcl_DStringAppend(&cmd_dstr, pWidName, -1);
   Tcl_DStringAppend(&cmd_dstr, " configure -text", -1);
   // append message as list element, so that '{' etc. is escaped properly
   Tcl_DStringAppendElement(&cmd_dstr, pMsg);

   eval_check(interp, Tcl_DStringValue(&cmd_dstr));

   Tcl_DStringFree(&cmd_dstr);
}

// ----------------------------------------------------------------------------
// Helper function for filling one line in ths histogram display
//
static void StatsWin_UpdateHistLine( uint idx )
{
   if (dbStatsWinState.histScaleY > 0)
   {
      uint v0 =      dbStatsWinState.hist[idx].expir;
      uint v1 = v0 + dbStatsWinState.hist[idx].day1cur;
      uint v2 = v1 + dbStatsWinState.hist[idx].day1old;
      uint v3 = v2 + dbStatsWinState.hist[idx].day2cur;
      uint v4 = v3 + dbStatsWinState.hist[idx].day2old;
      uint v5 = v4 + dbStatsWinState.hist[idx].day3cur;
      uint v6 = v5 + dbStatsWinState.hist[idx].day3old;

      sprintf(comm, "DbStatsWin_AddHistory .dbstats_ui %d %d %d %d %d %d %d %d\n", idx,
                    (STATS_DB_HIST_HEIGHT * v0 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v1 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v2 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v3 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v4 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v5 / dbStatsWinState.histScaleY),
                    (STATS_DB_HIST_HEIGHT * v6 / dbStatsWinState.histScaleY));
      eval_check(interp, comm);
   }
   else
      fatal0("StatsWin-UpdateHistLine: invalid scale\n");
}

// ----------------------------------------------------------------------------
// Refresh the complete history content
//
static void StatsWin_RefreshHist( void )
{
   if (dbStatsWinState.histNeedsReset == FALSE)
   {
      eval_check(interp, "DbStatsWin_ClearHistory .dbstats_ui\n");

      for (uint idx2 = 0; idx2 < STATS_DB_HIST_WIDTH; ++idx2)
      {
         StatsWin_UpdateHistLine(idx2);
      }
   }
}

// ----------------------------------------------------------------------------
// Update the history diagram data and the display, if open
// - ATTN: may be called while statistics window is not open
//
static void StatsWin_UpdateHist( const EPGDB_BLOCK_COUNT * pCount, time_t now )
{
   time_t updDelta = now - dbStatsWinState.histUpdateTs;

   if (dbStatsWinState.histNeedsReset)
   {
      dprintf0("StatsWin-UpdateHist: resetting history\n");
      dbStatsWinState.histNeedsReset = FALSE;
      dbStatsWinState.histScaleY = 1;
      dbStatsWinState.histIdx = 0;
      dbStatsWinState.histUpdateTs = now;
      memset(dbStatsWinState.hist, 0, sizeof(dbStatsWinState.hist));

      if (dbStatsWinState.open)
         eval_check(interp, "DbStatsWin_ClearHistory .dbstats_ui\n");
   }
   else if (dbStatsWinState.histIdx >= STATS_DB_HIST_WIDTH)
   {
      dbStatsWinState.histIdx = 0;
      dbStatsWinState.histUpdateTs = now;
   }
   else if (updDelta >= STATS_DB_HIST_UPD_FREQ)
   {
      dbStatsWinState.histIdx = (dbStatsWinState.histIdx + 1) % STATS_DB_HIST_WIDTH;
      dbStatsWinState.histUpdateTs = now;
   }
   // else: overwrite previous histIdx

   uint idx = dbStatsWinState.histIdx;
   uint total = pCount->day1[0] + pCount->day2[0] + pCount->day3[0] +
                pCount->day1[1] + pCount->day2[1] + pCount->day3[1] +
                pCount->expired + pCount->defective;

   if ((dbStatsWinState.histScaleY < total) && dbStatsWinState.open)
   {
      dprintf2("StatsWin-UpdateHist: rescaling from %d to %d\n", dbStatsWinState.histScaleY, total);

      dbStatsWinState.histScaleY = total * 5 / 4;  // 25% head-room for further increase
      StatsWin_RefreshHist();
   }

   ssize_t cnt = (now - dbStatsWinState.histUpdateTs) / STATS_DB_HIST_UPD_FREQ; 
   if (cnt < 1)
      cnt = 1;
   else if (cnt > STATS_DB_HIST_WIDTH)
      cnt = STATS_DB_HIST_WIDTH;

   for (uint repIdx = 0; repIdx < cnt; ++repIdx)
   {
      dbStatsWinState.hist[idx].expir = pCount->expired + pCount->defective;
      dbStatsWinState.hist[idx].day1cur = pCount->day1[0];
      dbStatsWinState.hist[idx].day1old = pCount->day1[1];
      dbStatsWinState.hist[idx].day2cur = pCount->day2[0];
      dbStatsWinState.hist[idx].day2old = pCount->day2[1];
      dbStatsWinState.hist[idx].day3cur = pCount->day3[0];
      dbStatsWinState.hist[idx].day3old = pCount->day3[1];

      if (dbStatsWinState.open)
         StatsWin_UpdateHistLine(idx);

      idx = (idx + 1) & STATS_DB_HIST_WIDTH;
   }
}

// ----------------------------------------------------------------------------
// Fill window with database statistics and pie chart
//
static void StatsWin_PrintDbStats( EPGDB_CONTEXT * dbc, EPGDB_BLOCK_COUNT * pCount )
{
   const AI_BLOCK *pAi;
   time_t lastAiUpdate;
   char  provname[60+1], datestr[25+1];
   uint  total, totalSinceAcq, anyDay[2];
   uint  netwopCount;

   // default values if database is empty
   strcpy(provname, "none yet");
   strcpy(datestr, "none yet");
   netwopCount = 0;

   if (dbc != NULL)
   {  // get provider name and db version from AI block
      EpgDbLockDatabase(dbc, TRUE);
      pAi = EpgDbGetAi(dbc);
      if (pAi != NULL)
      {
         strncpy(provname, AI_GET_SERVICENAME(pAi), sizeof(provname) - 1);
         provname[sizeof(provname) - 1] = 0;
         lastAiUpdate = EpgDbGetAiUpdateTime(dbc);
         strftime(datestr, 25, "%H:%M:%S %a %d.%m.", localtime(&lastAiUpdate));
         netwopCount = pAi->netwopCount;
      }
      EpgDbLockDatabase(dbc, FALSE);
   }

   anyDay[0] = pCount->day1[0] + pCount->day2[0] + pCount->day3[0];
   anyDay[1] = pCount->day1[1] + pCount->day2[1] + pCount->day3[1];
   total = anyDay[0] + anyDay[1] + pCount->expired + pCount->defective;
   totalSinceAcq = anyDay[0] + anyDay[1] + pCount->expiredSinceAcq;

   sprintf(comm, "EPG provider:       %s\n"
                 "Last update:        %s (%d%%)\n"
                 "Networks in db:     %d\n"
                 "Blocks in db:       %d\n"
                 "Blocks today/...:   %d / %d / %d\n"
                 "Expired total:      %d (%d%%)\n"
                 "Expired since acq.: %d (%d%%)\n"
                 "Defective blocks:   %d (%d%%)",
                 provname,
                 datestr, ACQ_COUNT_TO_PERCENT(anyDay[0], anyDay[0] + anyDay[1]),
                 netwopCount,
                 total,
                 pCount->day1[0] + pCount->day1[1],
                    pCount->day2[0] + pCount->day2[1],
                    pCount->day3[0] + pCount->day3[1],
                 pCount->expired, ACQ_COUNT_TO_PERCENT(pCount->expired, total),
                 pCount->expiredSinceAcq,
                    ACQ_COUNT_TO_PERCENT(pCount->expiredSinceAcq, totalSinceAcq),
                 pCount->defective, ACQ_COUNT_TO_PERCENT(pCount->defective, total)
          );

   // finally configure the popup text to show the string
   StatsWin_ConfigureLabelText(".dbstats_ui.browser.stat", comm);

   if (total > 0)
   {
      uint v0 =      pCount->defective + pCount->expired - pCount->expiredSinceAcq;
      uint v1 =      pCount->defective + pCount->expired;
      uint v2 = v1 + pCount->day1[0];
      uint v3 = v2 + pCount->day1[1];
      uint v4 = v3 + pCount->day2[0];
      uint v5 = v4 + pCount->day2[1];
      uint v6 = v5 + pCount->day3[0];
      uint v7 = v6 + pCount->day3[1];

      sprintf(comm, "DbStatsWin_PaintPie .dbstats_ui %d %d %d %d %d %d %d %d\n",
                                         (359 * v0 / total), (359 * v1 / total),
                                         (359 * v2 / total), (359 * v3 / total),
                                         (359 * v4 / total), (359 * v5 / total),
                                         (359 * v6 / total), (359 * v7 / total));
   }
   else
   {
      sprintf(comm, "DbStatsWin_ClearPie .dbstats_ui\n" );
   }
   eval_check(interp, comm);
}

// ----------------------------------------------------------------------------
// Fill window with Nextview acquisition status information
//
static void StatsWin_PrintAcqStats( EPGDB_CONTEXT * dbc, EPGACQ_DESCR * pAcqState, EPG_ACQ_STATS * sv )
{
   const char * pAcqModeStr;
   const char * pAcqPasvStr;
   char * pTtxNames = NULL;
   uint chanCount = 0;
   char * commBuf;
   int strOff;

   // allocate long string buffer - needed for channel name list
   const size_t commBufsize = TCL_COMM_BUF_SIZE + MAX_VBI_DVB_STREAMS * (18+50+2);
   commBuf = (char*) xmalloc(commBufsize);
   commBuf[0] = 0;
   strOff = 0;

#ifdef USE_DAEMON
   if (pAcqState->isNetAcq)
   {
      EPGDBSRV_DESCR netState;
      EpgAcqClient_DescribeNetState(&netState);
      switch(netState.state)
      {
         case NETDESCR_ERROR:
            strOff += sprintf(commBuf + strOff, "Network state:    error\nError cause:      %s\n",
                              ((netState.cause != NULL) ? netState.cause : "unknown"));
            break;
         case NETDESCR_CONNECT:
            strOff += sprintf(commBuf + strOff, "Network state:    server contacted\n");
            break;
         case NETDESCR_RUNNING:
            strOff += sprintf(commBuf + strOff, "Network state:    connected\n");
            break;
         case NETDESCR_DISABLED:
         default:
            strOff += sprintf(commBuf + strOff, "Network state:    unconnected\n");
            break;
      }
   }
#endif

   strOff += sprintf(commBuf + strOff,
                     "Channels done:    %d of %d (%d%%)\n"
                     "Acq runtime:      %02d:%02d (of %02d:%02d)\n",
                     pAcqState->ttxGrabDone, pAcqState->ttxSrcCount,
                        ACQ_COUNT_TO_PERCENT(pAcqState->ttxGrabDone, pAcqState->ttxSrcCount),
                     (sv->acqRuntime / 60), (sv->acqRuntime % 60),
                        (sv->acqDuration / 60), (sv->acqDuration % 60));

   EpgAcqCtl_GetAcqModeStr(pAcqState, /* forTtx := FALSE,*/ &pAcqModeStr, &pAcqPasvStr, NULL);
   if (EpgSetup_CheckTvCardConfig() == FALSE)
   {
      pAcqPasvStr = "TV card not configured";
   }
   strOff += sprintf(commBuf + strOff, "Acq mode:         %s\n", pAcqModeStr);
   if (pAcqPasvStr != NULL)
      strOff += sprintf(commBuf + strOff, "Passive reason:   %s\n", pAcqPasvStr);

   // append list of channel names currently received
   if (pAcqState->ttxGrabCount > 0)
   {
      strOff += sprintf(commBuf + strOff, "Receiving from:   ");
      WintvCfg_GetFreqTab(&pTtxNames, NULL, &chanCount, NULL);
      for (uint srcIdx = 0; srcIdx < pAcqState->ttxGrabCount; ++srcIdx)
      {
         if (pAcqState->ttxGrabIdx[srcIdx] < chanCount)
         {
            // NOTE length of leading space and name length limit need to match xalloc above!
            if (srcIdx != 0)
               strOff += sprintf(commBuf + strOff, "\n                  ");
            WintvCfg_ExtractName(pTtxNames, chanCount,
                                 pAcqState->ttxGrabIdx[srcIdx], commBuf + strOff, 50);
            strOff += strlen(commBuf + strOff);
         }
      }
      if (pTtxNames != NULL)
         xfree(pTtxNames);
   }

   // finally configure the popup text to show the string
   StatsWin_ConfigureLabelText(".dbstats_ui.acq.stat", commBuf);

   assert(strOff + 1 < commBufsize);
   xfree(commBuf);
}

// ----------------------------------------------------------------------------
// Update the database statistics window
// - consists of two parts:
//   + the upper one describes the current state of the database, with a pie chart
//     and statistics of PI block counts against the numbers from the AI block
//   + the lower one describes the current acquisition state and a histroy diagram
//     of current and past PI block count percentages
//
static void StatsWin_UpdateDbStatsWin( ClientData clientData )
{
   EPGDB_BLOCK_COUNT count;
   EPGACQ_DESCR acqState;
   EPG_ACQ_STATS sv;

   if (dbStatsWinState.open)
   {
      dprintf2("StatsWin-UpdateDbStatsWin: histShown?:%d histIdx:%d\n", dbStatsWinState.histShown, dbStatsWinState.histIdx);

      // acq not running for this database -> display db stats only
      time_t now = time(NULL);
      memset(&count, 0, sizeof(count));
      if (pUiDbContext != NULL)
      {
         EpgDbGetStat(pUiDbContext, &count, now, EpgAcqCtl_GetAcqBaseTime(now));
      }

      // print database statistics and pie chart
      StatsWin_PrintDbStats(pUiDbContext, &count);

      EpgAcqCtl_DescribeAcqState(&acqState);

      // append acq histogram if acq is working for browser DB
      if ( (acqState.ttxGrabState != ACQDESCR_DISABLED) && EpgSetup_IsAcqWorkingForUiDb() )
      {
         if (EpgAcqCtl_GetAcqStats(&sv) == FALSE)
         {
            memset(&sv, 0, sizeof(sv));
         }
         if (dbStatsWinState.histShown == FALSE)
         {
            sprintf(comm, "pack .dbstats_ui.acq -side top -anchor nw -fill both "
                                               "-after .dbstats_ui.browser\n");
            eval_check(interp, comm);

            dbStatsWinState.histShown = TRUE;
            StatsWin_RefreshHist();
         }

         // display graphical database fill percentage histogramm
         StatsWin_UpdateHist(&count, now);

         // text description
         StatsWin_PrintAcqStats(pUiDbContext, &acqState, &sv);

         // remove the old update timer
         if (dbStatsWinState.updateHandler != NULL)
         {
            Tcl_DeleteTimerHandler(dbStatsWinState.updateHandler);
         }
         // set up a timer to re-display the stats in case there's no EPG reception
         if ((acqState.ttxGrabState != ACQDESCR_DISABLED) && (acqState.isNetAcq == FALSE))
         {
            dbStatsWinState.updateHandler =
               Tcl_CreateTimerHandler(STATS_DB_ACQ_UPD_FREQ*1000, StatsWin_UpdateDbStatsWinTimeout, NULL);
         }
      }
      else
      {  // acq not running (at least for the same db)
         if (dbStatsWinState.histShown)
         {  // acq stats are still being displayed -> remove them
            sprintf(comm, ".dbstats_ui.acq.stat configure -text {}\n"
                          "pack forget .dbstats_ui.acq\n");
            eval_check(interp, comm);

            sprintf(comm, "DbStatsWin_ClearHistory .dbstats_ui\n");
            eval_check(interp, comm);

            dbStatsWinState.histShown = FALSE;
         }
      }
   }
}

// ----------------------------------------------------------------------------
// Update DB histogram while the statistics window is not open
//
static void StatsWin_UpdateDbHist( ClientData clientData )
{
   EPGDB_BLOCK_COUNT count;
   time_t now = time(NULL);

   if (dbStatsWinState.open == FALSE)
   {
      dprintf2("StatsWin-UpdateDbStatsWin: histShown?:%d histIdx:%d\n", dbStatsWinState.histShown, dbStatsWinState.histIdx);
      if (EpgDbGetStat(pUiDbContext, &count, now, EpgAcqCtl_GetAcqBaseTime(now)))
      {
         StatsWin_UpdateHist(&count, now);
      }
   }
}

// ----------------------------------------------------------------------------
// Update the teletext grabber statistics window
//
static void StatsWin_UpdateTtxStats( ClientData clientData )
{
   EPGACQ_DESCR acqState;
   EPG_ACQ_STATS sv;
   EPG_ACQ_VPS_PDC vpsPdc;
   const char * pAcqModeStr;
   const char * pAcqPasvStr;
   const char * pAcqStateStr;
   char idxBuf[20];

   if (statsWinTtx.open)
   {
      if (EpgAcqCtl_GetAcqStats(&sv) == FALSE)
      {
         memset(&sv, 0, sizeof(sv));
      }

      EpgAcqCtl_DescribeAcqState(&acqState);

      EpgAcqCtl_GetAcqModeStr(&acqState, &pAcqModeStr, &pAcqPasvStr, &pAcqStateStr);
      if ((pAcqPasvStr != NULL) && (EpgSetup_CheckTvCardConfig() == FALSE))
      {
         pAcqPasvStr = "TV card not configured";
      }

      comm[0] = 0;

#ifdef USE_DAEMON
      if (acqState.isNetAcq)
      {
         EPGDBSRV_DESCR netState;
         EpgAcqClient_DescribeNetState(&netState);

         switch(netState.state)
         {
            case NETDESCR_ERROR:
               sprintf(comm + strlen(comm), "Network state:    error\nError cause:      %s\n", ((netState.cause != NULL) ? netState.cause : "unknown"));
               break;
            case NETDESCR_CONNECT:
               sprintf(comm + strlen(comm), "Network state:    server contacted\n");
               break;
            case NETDESCR_RUNNING:
               sprintf(comm + strlen(comm), "Network state:    connected (rx %ld bytes)\n", netState.rxTotal);
               break;
            case NETDESCR_DISABLED:
            default:
               sprintf(comm + strlen(comm), "Network state:    unconnected\n");
               break;
         }
      }
#endif

      sprintf(comm + strlen(comm), "Acq mode:         %s\n"
                                   "Acq passive:      %s\n"
                                   "Channels done:    %d of %d (%d%%)\n"
                                   "Current channels: %d\n"
                                   "Acq runtime:      %02d:%02d (of %02d:%02d)\n"
                                   "Acq state:        %s",
                                   pAcqModeStr,
                                   ((pAcqPasvStr == NULL) ? "---" : pAcqPasvStr),
                                   acqState.ttxGrabDone, acqState.ttxSrcCount,
                                     ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount),
                                   acqState.ttxGrabCount,
                                   (sv.acqRuntime / 60), (sv.acqRuntime % 60),
                                      (sv.acqDuration / 60), (sv.acqDuration % 60),
                                   pAcqStateStr);

      // configure the popup text to show the string
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".fupp.stat", comm);

      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_0", "Channel name:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_1", "Channel VPS/PDC:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_2", "Capture range:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_3", "Captured pages:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_4", "Captured packets:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_5", "Decoding errors:");
      StatsWin_ConfigureLabelText(STATS_WIN_TTX_WNAM ".flow.stat_6", "TTX data rate [baud]:");

      // VPS
      // TODO move into stats array
      if (EpgAcqCtl_GetVpsPdc(&vpsPdc, VPSPDC_REQ_STATSWIN, FALSE) && (vpsPdc.cni != 0))
      {
         if ( VPS_PIL_IS_VALID(vpsPdc.pil) )
         {
            sprintf(comm, "CNI %04X\nPIL %02d.%02d.\n    %02d:%02d",
                          vpsPdc.cni,
                          (vpsPdc.pil >> 15) & 0x1F, (vpsPdc.pil >> 11) & 0x0F,
                          (vpsPdc.pil >>  6) & 0x1F, (vpsPdc.pil) & 0x3F);
         }
         else
         {
            sprintf(comm, "CNI %04X", vpsPdc.cni);
         }
      }
      else
         strcpy(comm, "---");

      sprintf(idxBuf, "%d", 1 * MAX_VBI_DVB_STREAMS + 0);
      Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);


      char * pTtxNames = NULL;
      uint chanCount = 0;
      WintvCfg_GetFreqTab(&pTtxNames, NULL, &chanCount, NULL);

      for (uint srcIdx = 0; srcIdx < acqState.ttxGrabCount; ++srcIdx)
      {
         // channel name
         if (acqState.ttxGrabIdx[srcIdx] < chanCount)
            WintvCfg_ExtractName(pTtxNames, chanCount, acqState.ttxGrabIdx[srcIdx], comm, 18);
         else
            sprintf(comm, "channel #%d", acqState.ttxGrabIdx[srcIdx]);
         sprintf(idxBuf, "%d", 0 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);

         // Captured range
         sprintf(comm, "%03X-%03X",
                       sv.pkgStats[srcIdx].ttxPageStartNo,
                       sv.pkgStats[srcIdx].ttxPageStopNo);
         sprintf(idxBuf, "%d", 2 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);

         // Captured pages
         sprintf(comm, "%d", sv.pkgStats[srcIdx].ttxPagCount);
         sprintf(idxBuf, "%d", 3 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);

         // Captured packets
         sprintf(comm, "%d\n%1.1f%% of TTX",
                       sv.pkgStats[srcIdx].ttxPkgCount,
                       ((sv.ttx_dec[srcIdx].ttxPkgCount > 0) ? ((double)sv.pkgStats[srcIdx].ttxPkgCount*100.0/sv.ttx_dec[srcIdx].ttxPkgCount) : 0.0));
         sprintf(idxBuf, "%d", 4 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);

         // Decoder quality
         sprintf(comm, "%d (%d%%)",
                       sv.pkgStats[srcIdx].ttxPkgParErr, //sv.pkgStats[srcIdx].ttxPkgStrSum,
                       ((sv.pkgStats[srcIdx].ttxPkgStrSum > 0) ? (sv.pkgStats[srcIdx].ttxPkgParErr * 100 / sv.pkgStats[srcIdx].ttxPkgStrSum) : 0));
         sprintf(idxBuf, "%d", 5 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);

         // TTX data rate
         sprintf(comm, "%d",
                       ((sv.acqDuration > 0) ? (int)((sv.ttx_dec[srcIdx].ttxPkgCount*45*8)/sv.acqDuration) : 0));
         sprintf(idxBuf, "%d", 6 * MAX_VBI_DVB_STREAMS + srcIdx);
         Tcl_SetVar2Ex(interp, "stats_ttx_tab", idxBuf, Tcl_NewStringObj(comm, -1), 0);
      }
      if (pTtxNames != NULL)
         xfree(pTtxNames);

      // make newly used columns visible
      for (uint srcIdx = statsWinTtx.usedCols; srcIdx < acqState.ttxGrabCount; ++srcIdx)
      {
         for (uint rowIdx = 0; rowIdx < STATS_WIN_TTX_ROWS; ++rowIdx)
         {
            sprintf(comm, "grid " STATS_WIN_TTX_WNAM ".flow.tab_%d_%d", rowIdx, srcIdx);
            eval_check(interp, comm);
         }
      }
      // hide unused columns
      for (uint srcIdx = acqState.ttxGrabCount; srcIdx < statsWinTtx.usedCols; ++srcIdx)
      {
         for (uint rowIdx = 0; rowIdx < STATS_WIN_TTX_ROWS; ++rowIdx)
         {
            sprintf(comm, "grid remove " STATS_WIN_TTX_WNAM ".flow.tab_%d_%d", rowIdx, srcIdx);
            eval_check(interp, comm);
         }
      }
      statsWinTtx.usedCols = acqState.ttxGrabCount;

      // remove the old update timer
      if (statsWinTtx.updateHandler != NULL)
         Tcl_DeleteTimerHandler(statsWinTtx.updateHandler);
      // set up a timer to re-display the stats in case there's no TTX reception
      if ((acqState.ttxGrabState != ACQDESCR_DISABLED) && (acqState.isNetAcq == FALSE))
         statsWinTtx.updateHandler =
            Tcl_CreateTimerHandler(STATS_TTX_UPD_FREQ*1000, StatsWin_UpdateTtxStats, NULL);
   }
}

// ----------------------------------------------------------------------------
// Schedule update of stats window after timeout
// - used only for stats windows with acquisition
// - timeout occurs when no AI is received
//
static void StatsWin_UpdateDbStatsWinTimeout( ClientData clientData )
{
   dbStatsWinState.updateHandler = NULL;
   AddMainIdleEvent(StatsWin_UpdateDbStatsWin, clientData, FALSE);
}

// ----------------------------------------------------------------------------
// Update status line of browser main window
// - possible bits of information about browser db:
//   + note if database is empty or all expired
//   + time & date of last database update
//   + percentage of expired PI
// - possible bits of information about acq:
//   + state: Off, Startup, Running, Stalled
//   + CNI in acq db
//   + mode: forced-passive & reason, passive, cycle state
//
static void StatsWin_UpdateMainStatusLine( ClientData clientData )
{
   EPGDB_BLOCK_COUNT count;
   EPGACQ_DESCR acqState;
   const AI_BLOCK *pAi;
   char  provName[40];
   uint  curTotal;
   time_t dbAge;
   bool isPassiveAcq;
   #ifdef USE_DAEMON
   EPGDBSRV_DESCR netState;
   #endif

   dprintf0("StatsWin-UpdateDbStatusLine: called\n");

   comm[0] = 0;

   if (EpgDbContextGetCni(pUiDbContext) != 0)
   {
      // compute database block statistics
      time_t now = time(NULL);
      time_t startToday = EpgAcqCtl_GetAcqBaseTime(now);
      time_t lastUpdate = EpgDbGetAiUpdateTime(pUiDbContext);
      EpgDbGetStat(pUiDbContext, &count, now, startToday);

      // get name of UI provider network
      EpgDbLockDatabase(pUiDbContext, TRUE);
      pAi = EpgDbGetAi(pUiDbContext);
      if (EpgDbContextIsMerged(pUiDbContext))
         sprintf(comm + strlen(comm), "Merged database");
      else if (pAi != NULL)
         sprintf(comm + strlen(comm), "%s", AI_GET_SERVICENAME(pAi));
      else
         strcat(comm, "Browser database");
      EpgDbLockDatabase(pUiDbContext, FALSE);

      curTotal = count.day1[0] + count.day2[0] + count.day3[0] +
                count.day1[1] + count.day2[1] + count.day3[1];

      // warn about age of database
      dbAge = (now - lastUpdate) / 60;
      if (dbAge >= 7*24*60)
         sprintf(comm + strlen(comm), ", %1.1f weeks old", (double)dbAge / (7*24*60));
      else if (dbAge >= 24*60)
         sprintf(comm + strlen(comm), ", %1.1f days old", (double)dbAge / (24*60));
      else if (lastUpdate < startToday)
         sprintf(comm + strlen(comm), ", %ld hours old", (dbAge + 60/2) / 60);

      // print percentage of PI that are expired since time of acquisition
      if (curTotal == 0)
      {
         if (count.expired == 0)
            strcat(comm, ", is empty");
         else
            strcat(comm, ", is fully expired");
      }
      else if ((count.expiredSinceAcq > 0) && (lastUpdate < startToday))
      {
         sprintf(comm + strlen(comm), ", %d%% expired",
                 ACQ_COUNT_TO_PERCENT(count.expiredSinceAcq, (curTotal + count.expiredSinceAcq)));
      }
      strcat(comm, ". ");
   }

   // describe acq state (disabled, network connect, running)
   if (RcFile_Query()->ttx.ttx_enable)
   {
      // fetch current state and acq db statistics from acq control
      EpgAcqCtl_DescribeAcqState(&acqState);
      provName[0] = 0;

      {
         char * pTtxNames = NULL;
         uint chanCount;

         if ( WintvCfg_GetFreqTab(&pTtxNames, NULL, &chanCount, NULL) &&
              (acqState.ttxGrabIdx[0] >= 0) && (acqState.ttxGrabIdx[0] < (int)chanCount))
         {
            WintvCfg_ExtractName(pTtxNames, chanCount, acqState.ttxGrabIdx[0], provName, sizeof(provName));
         }
         if (pTtxNames != NULL)
            xfree(pTtxNames);
      }


      #ifdef USE_DAEMON
      if (acqState.isNetAcq)
      {
         if ( EpgAcqClient_DescribeNetState(&netState) )
         {
            // network connection to acquisition server is not set up -> describe network state instead
            switch (netState.state)
            {
               case NETDESCR_CONNECT:
                  strcat(comm, "Acquisition: connecting to server..");
                  break;
               case NETDESCR_ERROR:
               case NETDESCR_DISABLED:
                  strcat(comm, "Acquisition stalled: network error");
                  break;
               case NETDESCR_RUNNING:
                  if (acqState.ttxGrabState == ACQDESCR_NET_CONNECT)
                  {  // note: in state RUNNING display "loading" until the first stats report is available
                     strcat(comm, "Acquisition: connecting to server..");
                  }
                  break;
               default:
                  fatal1("StatsWin-UpdateDbStatusLine: unknown net state %d", netState.state);
                  break;
            }

            if (netState.state != NETDESCR_RUNNING)
            {  // set acq state to suppress additional output (e.g. acq phase)
               acqState.ttxGrabState = ACQDESCR_NET_CONNECT;
            }
         }
      }
      #endif

      isPassiveAcq = (acqState.mode == ACQMODE_PASSIVE) ||
                     (acqState.passiveReason != ACQPASSIVE_NONE);

      switch (acqState.ttxGrabState)
      {
         case ACQDESCR_DISABLED:
            strcat(comm, "Acquisition is disabled");
            break;
         case ACQDESCR_NET_CONNECT:
         case ACQDESCR_SCAN:
            break;
         case ACQDESCR_STARTING:
            if ((isPassiveAcq == FALSE) && (provName[0] != 0))
            {
               sprintf(comm + strlen(comm), "Acquisition is starting up for %s", provName);
            }
            else
               strcat(comm, "Acquisition is waiting for reception");
            break;
         case ACQDESCR_TTX_PG_SEQ_SCAN:
            strcat(comm, "Acquisition scanning teletext");
            break;
         case ACQDESCR_NO_RECEPTION:
            if (EpgSetup_CheckTvCardConfig() == FALSE)
            {
               strcat(comm, "Acquisition: TV card not configured");
            }
            else if ((isPassiveAcq == FALSE) && (provName[0] != 0))
            {
               sprintf(comm + strlen(comm), "Acquisition: no reception on %s", provName);
            }
            else
               strcat(comm, "Acquisition: no teletext reception");
            break;
         case ACQDESCR_IDLE:
            strcat(comm, "Acquisition: idle");
            break;
         case ACQDESCR_RUNNING:
            if (provName[0] != 0)
            {
               if (acqState.cyclePhase == ACQMODE_PHASE_MONITOR)
                  sprintf(comm + strlen(comm), "Acquisition complete, refreshing %s", provName);
               else
                  sprintf(comm + strlen(comm), "Acquisition working on %s", provName);
            }
            else
            {  // internal inconsistancy
               //TODO fatal0("StatsWin-UpdateDbStatusLine: no AI block while in state RUNNING");
               sprintf(comm + strlen(comm), "Acquisition in progress..");
               // patch state to prevent further output
               acqState.ttxGrabState = ACQDESCR_NET_CONNECT;
            }
            break;

         default:
            fatal1("StatsWin-UpdateDbStatusLine: unknown acq state %d", acqState.ttxGrabState);
      }

      // describe acq mode, warn the user if passive
      if ( (acqState.ttxGrabState != ACQDESCR_NET_CONNECT) &&
           (acqState.ttxGrabState != ACQDESCR_DISABLED) &&
           (acqState.ttxGrabState != ACQDESCR_SCAN))
      {
         if (acqState.mode == ACQMODE_PASSIVE)
         {
            strcat(comm, " (passive mode)");
         }
         else if (acqState.passiveReason != ACQPASSIVE_NONE)
         {
            strcat(comm, " (forced passive)");
         }
         else if (acqState.mode == ACQMODE_CYCLIC_2)
         {
            // completeness for MONITOR state already stated above
            if (acqState.cyclePhase != ACQMODE_PHASE_MONITOR)
            {
               sprintf(comm + strlen(comm), ", overall %d%% complete",
                       ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
            }
         }
         else
         {
            switch (acqState.cyclePhase)
            {
               case ACQMODE_PHASE_NOWNEXT:
                  sprintf(comm + strlen(comm), " phase 'Now', %d%% complete",
                          ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
                  break;
               case ACQMODE_PHASE_FULL:
                  sprintf(comm + strlen(comm), " phase 'Full', %d%% complete",
                          ACQ_COUNT_TO_PERCENT(acqState.ttxGrabDone, acqState.ttxSrcCount));
                  break;
               case ACQMODE_PHASE_MONITOR:
                  // completeness for MONITOR state already stated above
                  break;
               default:
                  break;
            }
         }
      }

      switch (acqState.ttxGrabState)
      {
         case ACQDESCR_SCAN:
            break;
         case ACQDESCR_STARTING:
         case ACQDESCR_TTX_PG_SEQ_SCAN:
            strcat(comm, "...");
            break;
         default:
            strcat(comm, ".");
            break;
      }
   }

   if (Tcl_SetVar(interp, "dbstatus_line", comm, TCL_GLOBAL_ONLY) == NULL)
   {
      debugTclErr(interp, "assigning to var dbstatus_line");
   }
}

// ----------------------------------------------------------------------------
// Open or close window with db and acq statistics
// - called by the "View (acq) statistics" menu entries (toggle mode, argc=2)
//   or as a callback when a statistics window is destroyed
//
static int StatsWin_ToggleDbStats( ClientData ttp, Tcl_Interp *interp, int argc, CONST84 char *argv[] )
{
   const char * const pUsage = "Usage: C_StatsWin_ToggleDbStats [0|1]";
   int newState;
   int result = TCL_OK;

   if ( (argc < 1) || (argc > 2) ||
        ((argc == 2) && (Tcl_GetBoolean(interp, argv[1], &newState) != TCL_OK)) )
   {
      Tcl_SetResult(interp, (char *)pUsage, TCL_STATIC);
      result = TCL_ERROR;
   }
   else
   {
      result = TCL_OK;

      // determine new state from optional second parameter: 0, 1 or toggle
      if (argc == 1)
      {  // no state parameter -> toggle state
         newState = ! dbStatsWinState.open;
      }

      if (newState != dbStatsWinState.open)
      {
         if (dbStatsWinState.open == FALSE)
         {  // window shall be opened
            sprintf(comm, "DbStatsWin_Create .dbstats_ui\n");
            eval_check(interp, comm);

            dbStatsWinState.open = TRUE;
            dbStatsWinState.histShown = FALSE;
            dbStatsWinState.updateHandler = NULL;

            // enable extended statistics reports
            EpgAcqCtl_EnableAcqStats(TRUE, statsWinTtx.open);

            // display initial summary
            StatsWin_UpdateDbStatsWin(NULL);
         }
         else
         {  // destroy the window

            // note: set to FALSE before window destruction to avoid recursion
            dbStatsWinState.open = FALSE;

            sprintf(comm, "destroy .dbstats_ui");
            eval_check(interp, comm);

            // disable extended statistics reports when all windows are closed
            if (statsWinTtx.open == FALSE)
            {
               EpgAcqCtl_EnableAcqStats(statsWinTtx.open, statsWinTtx.open);
            }
         }
         // set the state of the checkbutton of the respective menu entry
         Tcl_SetVar2Ex(interp, "menuStatusDbStatsOpen", NULL,
                               Tcl_NewIntObj(dbStatsWinState.open), 0);
      }
   }

   return result;
}

// ----------------------------------------------------------------------------
// Open or close window with teletext grabber statistics
//
static int StatsWin_ToggleTtxStats( ClientData ttp, Tcl_Interp *interp, int argc, CONST84 char *argv[] )
{
   const char * const pUsage = "Usage: C_StatsWin_ToggleTtxStats [0|1]";
   int newState;
   int result;

   if ( (argc < 1) || (argc > 2) ||
        ((argc == 2) && (Tcl_GetBoolean(interp, argv[1], &newState) != TCL_OK)) )
   {
      Tcl_SetResult(interp, (char *)pUsage, TCL_STATIC);
      result = TCL_ERROR;
   }
   else
   {
      if (argc == 1)
      {
         newState = ! statsWinTtx.open;
      }

      if (newState != statsWinTtx.open)
      {
         if (statsWinTtx.open == FALSE)
         {  // window shall be opened
            sprintf(comm, "StatsWinTtx_Create %s %d %d\n",
                          STATS_WIN_TTX_WNAM, STATS_WIN_TTX_ROWS, MAX_VBI_DVB_STREAMS);
            eval_check(interp, comm);

            statsWinTtx.open = TRUE;
            statsWinTtx.usedCols = 0;
            statsWinTtx.updateHandler = NULL;

            // enable extended statistics reports
            EpgAcqCtl_EnableAcqStats(TRUE, TRUE);

            // display initial summary
            StatsWin_UpdateTtxStats(NULL);
         }
         else
         {  // destroy the window

            // note: set to FALSE before window destruction to avoid recursion
            statsWinTtx.open = FALSE;

            sprintf(comm, "destroy %s", STATS_WIN_TTX_WNAM);
            eval_check(interp, comm);

            // switch to low reporting interval, or disable extended reports when all windows closed
            EpgAcqCtl_EnableAcqStats(!dbStatsWinState.open, FALSE);
         }
         // set the state of the checkbutton of the according menu entry
         Tcl_SetVar2Ex(interp, "menuStatusAcqStatsOpen", NULL,
                               Tcl_NewIntObj(statsWinTtx.open), 0);
      }
      result = TCL_OK;
   }

   return result;
}

// ----------------------------------------------------------------------------
// Schedule an update of all statistics output
// - argument target says which statistics popup needs to be updated.
//   Since the main window status line contains info about both acq and ui db
//   its update is unconditional.
// - the function is triggered by acq control regularily upon every DB update
//   and after provider changes or after acquisition parameters are changed
//   or after a provider change by the user for the browser database
// - the function is also triggered by GUI provider changes
//   plus regularily every minute (to update expiration statistics)
//
void StatsWin_UiStatsUpdate( bool provChange, bool dbUpdate )
{
   dprintf2("StatsWin-UiStatsUpdate: provChange:%d dbUpdate:%d\n", provChange, dbUpdate);

   if (provChange)
   {
      dbStatsWinState.histNeedsReset = TRUE;
   }
   if (dbStatsWinState.open)
   {
      AddMainIdleEvent(StatsWin_UpdateDbStatsWin, NULL, TRUE);
   }
   else if (dbUpdate)
   {
      AddMainIdleEvent(StatsWin_UpdateDbHist, NULL, TRUE);
   }
   if (provChange || dbUpdate)
   {
      AddMainIdleEvent(StatsWin_UpdateMainStatusLine, NULL, TRUE);
   }
}

// ----------------------------------------------------------------------------
// Schedule an update of all statistics output
//
void StatsWin_AcqStatsUpdate( bool provChange )
{
   dprintf1("StatsWin-AcqStatsUpdate: provChange:%d\n", provChange);

   if (dbStatsWinState.open && (dbStatsWinState.histShown || provChange))
   {
      AddMainIdleEvent(StatsWin_UpdateDbStatsWin, NULL, TRUE);
   }
   if (statsWinTtx.open)
   {
      AddMainIdleEvent(StatsWin_UpdateTtxStats, NULL, TRUE);
   }
   AddMainIdleEvent(StatsWin_UpdateMainStatusLine, NULL, TRUE);
}

// ----------------------------------------------------------------------------
// Initialize module state variables
// - this should be called only once during start-up
//
void StatsWin_Create( void )
{
   Tcl_CmdInfo cmdInfo;

   if (Tcl_GetCommandInfo(interp, "C_StatsWin_ToggleDbStats", &cmdInfo) == 0)
   {
      Tcl_CreateCommand(interp, "C_StatsWin_ToggleDbStats", StatsWin_ToggleDbStats, (ClientData) NULL, NULL);
      Tcl_CreateCommand(interp, "C_StatsWin_ToggleTtxStats", StatsWin_ToggleTtxStats, (ClientData) NULL, NULL);
   }
   else
      fatal0("StatsWin-Create: commands are already created");

   memset(&dbStatsWinState, 0, sizeof(dbStatsWinState));
   dbStatsWinState.histNeedsReset = TRUE;
}
